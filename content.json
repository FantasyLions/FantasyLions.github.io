{"meta":{"title":"Serio's blog","subtitle":"","description":"","author":"Serio","url":"https://fantasylion.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-03-31T04:57:48.954Z","updated":"2020-03-31T04:57:48.954Z","comments":false,"path":"/404.html","permalink":"https://fantasylion.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-31T04:57:48.970Z","updated":"2020-03-31T04:57:48.970Z","comments":false,"path":"about/index.html","permalink":"https://fantasylion.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-03-31T04:57:48.970Z","updated":"2020-03-31T04:57:48.970Z","comments":false,"path":"books/index.html","permalink":"https://fantasylion.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-31T04:57:48.971Z","updated":"2020-03-31T04:57:48.971Z","comments":false,"path":"categories/index.html","permalink":"https://fantasylion.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-03-31T04:57:48.972Z","updated":"2020-03-31T04:57:48.972Z","comments":false,"path":"repository/index.html","permalink":"https://fantasylion.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-03-31T04:57:48.971Z","updated":"2020-03-31T04:57:48.971Z","comments":true,"path":"links/index.html","permalink":"https://fantasylion.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-31T04:57:48.972Z","updated":"2020-03-31T04:57:48.972Z","comments":false,"path":"tags/index.html","permalink":"https://fantasylion.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MySql 锁机制整理","slug":"2020-11-12-mysql-lock","date":"2020-11-11T16:03:51.000Z","updated":"2020-11-11T16:03:51.000Z","comments":true,"path":"MySql/2020-11-12-mysql-lock/","link":"","permalink":"https://fantasylion.github.io/MySql/2020-11-12-mysql-lock/","excerpt":"","text":"MySql 锁机制整理 最近因为公司经常出现数据库死锁长事务等问题，所以研究了下 MySql 锁机制。本文主要用于梳理最近的研究成果可能会有很多理解错误的地方。 在 MySql 下不同的存储引擎会使用不同的锁，这里主要梳理常见的InnoDB存储引擎使用的锁。 MySql 锁划分 从 mysql 层面划分包含以下锁 Lock X Lock 排他锁，允许事务删除或更新一行数据，此时无法再加上其他锁。 S Lock 共享锁，允许事务读一行数据，此时可以再加共享锁（S Lock/IS Lock） Auto-Inc Locks 自增长锁 ，主键自增长，为了提高插入的性能，自增长锁不是一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即是释放的。 IS Lock 意向共享锁，事务想要获得一张表中某几行的共享锁 IX Lock 意向排他锁，事务想要获得一张表中某几行的排他锁 意向锁位表级别锁，设计的目的主要是为了在一个事务中国揭示下一行将被请求的锁类型 互斥或兼容关系 None X Lock S Lock X Lock 不兼容 不兼容 S Lock 不兼容 兼容 None AI Lock IS Lock IX Lock S Lock X Lock AI Lock 不兼容 兼容 兼容 不兼容 不兼容 IS Lock 兼容 兼容 兼容 兼容 不兼容 IX Lock 兼容 兼容 兼容 不兼容 不兼容 S Lock 不兼容 兼容 不兼容 兼容 不兼容 X Lock 不兼容 不兼容 不兼容 不兼容 不兼容 隐式锁 隐式锁（implicit lock）必然为 x-lock ，是指索引记录逻辑上有 x-lock，但实际在内存对象中并不包含有这个锁信息。 聚集索引记录的隐式锁，通过聚集索引记录的事务ID 可以查询到该事务为活跃事务，则此聚集索引记录上有隐式索引 辅助索引记录的隐式锁，通过 page header 的 PAGE_MAX_TRX_ID（保存的最大事务ID）进行判断，或通过辅助索引记录的聚集索引事务判断 显式锁 显式锁（explicit lock），分为 gap explicit lock 和 no gap explicit lock（gap 通过 type_mode 中 LOCK_GAP 来进行设置）。 no gap explict lock 锁住的是记录以及记录之前的范围，否则，仅锁住范围。explicit lock 可以是 s-lock 也可以是 x-lock。 算法 Record Lock 单个行记录上的锁，会去锁住索引记录。如果Inno DB 存储引擎表在建立的时候没有设置任务一个索引，那么这时 InnoDB 存储引擎会使用隐式的主键来进行锁定。 Gap Lock 间隙锁，锁定一个范围，但不包含记录本身 Next-Key Lock Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。设计的目的是为了解决 Phantom Problem（幻读） 以上三种算法都属于行级锁，从下方代码中可以看出行锁是根据页的组织形式来进行管理的，并以 bitmap 的形式记录页中哪些数据上了锁。 12345struct lock_rec_struct&#123; ulint space; /* space id */ ulint page_no; /* page number */ ulint n_bits; /* number of bits in the lock bitmap */&#125; 123456/* A table lock */typedef struct lock_table_struct lock_table_t;struct lock_table_struct&#123; dict_table_t* table; /* database table in dictionary cache */ UT_LIST_NODE_T(lock_t)locks; /* list of locks on the same table */&#125; 123456789101112/* Lock struct */struct lock_struct&#123; trx_t* trx; /* transaction owning the lock */ UT_LIST_NODE_T(lock_t)trx_locks; /* list of the locks of thetransaction */ ulint type_mode; /* lock type, mode, gap flag, andwait flag, 0Red */ hash_node_t hash; /* hash chain node for a record lock */ dict_index_t* index; /* index for a record lock */ union&#123; lock_table_t tab_lock; /* table lock */ lock_rec_t rec_lock; /* record lock */ &#125; un_member;&#125; 粒度 表锁 页锁 行锁 MVCC Multi-Version Concurrency Control 多版本并发控制 多版本并发控制(Multiversion concurrency control， MCC 或 MVCC)，是数据库管理系统常用的一种并发控制，也用于程序设计语言实现事务内存。 MVCC意图解决读写锁造成的多个、长时间的读操作饿死写操作问题。每个事务读到的数据项都是一个历史快照（snapshot)并依赖于实现的隔离级别。写操作不覆盖已有数据项，而是创建一个新的版本，直至所在操作提交时才变为可见。快照隔离使得事物看到它启动时的数据状态。 一致性非锁定读 如果读取的行正在执行 DELETE 或 UPDATE 操作，这个时读取操作不会因此去等待行上锁的释放。相反地，InnoDB 存储引擎会去读取行的一个快照数据。 一致性锁定读 事务隔离级别 REPEATABLE READ 模式下，InnoDB select 操作使用一致性非锁定读，但在某些情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。InnoDB 对 select 语句支持两种一致性的锁定读操作： SELECT ... FOR UPDATE 加上一个 X Lock SELECT ... LOCK IN SHARE MODE 加上一个 S Lock Latch Latch 是用来保证并发线程炒作临界资源的正确性，通常又非为 Mutex（互斥锁）和 RWLock（读写锁） Mutex（英文Mutual Exclusion 缩写），InnoDB用于表示内部内存数据结构并对其执行强制互斥锁的低级对象。 一旦获取了锁，就可以防止任何其他进程，线程等获取相同的锁。 与rw-locks形成对比，InnoDB使用rw-locks表示并强制对内部内存数据结构的共享访问锁。","categories":[{"name":"MySql","slug":"MySql","permalink":"https://fantasylion.github.io/categories/MySql/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://fantasylion.github.io/tags/MySql/"}]},{"title":"Sentinel 熔断等指标如何统计以及如何判断熔断点","slug":"2020-07-29-Sentinel-Source-code-analysis","date":"2020-07-29T06:14:51.000Z","updated":"2020-07-29T06:14:51.000Z","comments":true,"path":"java/2020-07-29-Sentinel-Source-code-analysis/","link":"","permalink":"https://fantasylion.github.io/java/2020-07-29-Sentinel-Source-code-analysis/","excerpt":"","text":"Sentinel 熔断等指标如何统计以及如何判断熔断点 Sentinel 使用 在分析源码之前首先看下，Sentinel 如何使用 建立规则 12345678910111213// 建立规则List&lt;DegradeRule&gt; rule = new ArrayList&lt;DegradeRule&gt;();DegradeRule ruleRatio = new DegradeRule();ruleRatio.setResource(\"sourceTest\");ruleRatio.setCount(100);ruleRatio.setGrade(1);ruleRatio.setTimeWindow(60)ruleRatio.setMinRequestAmount(2);ruleRatio.setRtSlowRequestAmount(2);rules.add(ruleRatio);// 加载规则DegradeRuleManager.loadRules(rules); 使用规则 1234567891011121314151617Entry entry = null;try &#123; entry = SphU.entry( \"sourceTest\" ) print(\"Do something.\");&#125; catch( DegradeException degradeException ) &#123; logger.error(\"触发熔断,熔断器：&#123;&#125;\", JSON.toJSONString(degradeException.rule) ) throw new DegradeException(\"触发熔断\"+degradeException.rule.resource, degradeException)&#125; catch (Exception e) &#123; Tracer.trace(e) logger.error(\"有异常\") throw e&#125; finally &#123; if (entry != null) &#123; // 退出 Entry 并统计 entry.exit() &#125;&#125; 从上面的代码中大致可以看出，sentinel 通过 SphU.entry 验证规则并开始统计，如果其中某条规则不通过将会抛出对应的异常， 通过 entry.exit() 结束统计。 下面进入到源码中分析具体的实现原理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public static final Sph sph = new CtSph();public static Entry entry(String name) throws BlockException &#123; return Env.sph.entry(name, EntryType.OUT, 1, OBJECTS0); // @1 -&gt; @2&#125;// @2// Env.sph.entrypublic Entry entry(String name, EntryType type, int count, Object... args) throws BlockException &#123; // 创建一个资源名包装类 StringResourceWrapper resource = new StringResourceWrapper(name, type); return entry(resource, count, args); // @3 -&gt; @4&#125;// @4public Entry entry(ResourceWrapper resourceWrapper, int count, Object... args) throws BlockException &#123; return entryWithPriority(resourceWrapper, count, false, args); // @5 -&gt; @6&#125;// @6private Entry entryWithPriority(ResourceWrapper resourceWrapper, int count, boolean prioritized, Object... args) throws BlockException &#123; // 从线程变量中获取当前上下文 Context context = ContextUtil.getContext(); // ... 省略部分代码 if (context == null) &#123; // Using default context. // 如果没有上下文，创建一个默认的上下文和一个EntranceNode context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME); &#125; // 如果全局开关关闭，不需要检查规则和统计 // Global switch is close, no rule checking will do. if (!Constants.ON) &#123; return new CtEntry(resourceWrapper, null, context); &#125; // 找到所有的处理责任链【责任链模式】 ProcessorSlot&lt;Object&gt; chain = lookProcessChain(resourceWrapper); /* * 说明责任链数量已经超出最大允许数量，后面将没有规则会被检查 * Means amount of resources (slot chain) exceeds &#123;@link Constants.MAX_SLOT_CHAIN_SIZE&#125;, * so no rule checking will be done. */ if (chain == null) &#123; return new CtEntry(resourceWrapper, null, context); &#125; // 创建当前条目 Entry e = new CtEntry(resourceWrapper, chain, context); try &#123; // 触发责任链（从第一个开始执行到最后一个责任链节点，主要有创建节点、统计指标、验证各种规则...） chain.entry(context, resourceWrapper, null, count, prioritized, args); &#125; catch (BlockException e1) &#123; // 被阻塞后退出当前条目，并统计指标 e.exit(count, args); throw e1; &#125; catch (Throwable e1) &#123; // This should not happen, unless there are errors existing in Sentinel internal. RecordLog.info(\"Sentinel unexpected exception\", e1); &#125; return e;&#125; 责任链模式 以上 entryWithPriority 源码中可以 sentinel 用到了责任链模式，通过责任链创建节点、统计指标、验证规则…。 接下看下 Sentinel 是如何实现责任链模式又是如何统计指标和验证规则的。 1234567// 在没有调用链，并且调用链没有超过最大允许数时，初始化一个chain = SlotChainProvider.newSlotChain();Map&lt;ResourceWrapper, ProcessorSlotChain&gt; newMap = new HashMap&lt;ResourceWrapper, ProcessorSlotChain&gt;( chainMap.size() + 1);newMap.putAll(chainMap);newMap.put(resourceWrapper, chain);chainMap = newMap; 123// 获取到一个默认的slot调用链构建器，并开始构建slotChainBuilder = SpiLoader.loadFirstInstanceOrDefault(SlotChainBuilder.class, DefaultSlotChainBuilder.class);slotChainBuilder.build(); 123456789101112131415161718public ProcessorSlotChain build() &#123; // 创建调用链对象 ProcessorSlotChain chain = new DefaultProcessorSlotChain(); // Note: the instances of ProcessorSlot should be different, since they are not stateless. // 通过SPI发现并加载并排序所有的调用链节点 List&lt;ProcessorSlot&gt; sortedSlotList = SpiLoader.loadPrototypeInstanceListSorted(ProcessorSlot.class); for (ProcessorSlot slot : sortedSlotList) &#123; if (!(slot instanceof AbstractLinkedProcessorSlot)) &#123; RecordLog.warn(\"The ProcessorSlot(\" + slot.getClass().getCanonicalName() + \") is not an instance of AbstractLinkedProcessorSlot, can't be added into ProcessorSlotChain\"); continue; &#125; // 按顺序依次将调用链节点添加都最后一个，并关联下一个节点 chain.addLast((AbstractLinkedProcessorSlot&lt;?&gt;) slot); &#125; return chain;&#125; 1234567891011121314151617181920212223242526272829public static &lt;T&gt; List&lt;T&gt; loadPrototypeInstanceListSorted(Class&lt;T&gt; clazz) &#123; try &#123; // @1 // Not use SERVICE_LOADER_MAP, to make sure the instances loaded are different. ServiceLoader&lt;T&gt; serviceLoader = ServiceLoaderUtil.getServiceLoader(clazz); List&lt;SpiOrderWrapper&lt;T&gt;&gt; orderWrappers = new ArrayList&lt;&gt;(); for ( T spi : serviceLoader ) &#123; // @2 int order = SpiOrderResolver.resolveOrder(spi); // @3 // Since SPI is lazy initialized in ServiceLoader, we use online sort algorithm here. SpiOrderResolver.insertSorted(orderWrappers, spi, order); RecordLog.debug(\"[SpiLoader] Found &#123;&#125; SPI: &#123;&#125; with order &#123;&#125;\", clazz.getSimpleName(), spi.getClass().getCanonicalName(), order); &#125; List&lt;T&gt; list = new ArrayList&lt;&gt;(orderWrappers.size()); // @4 for (int i = 0; i &lt; orderWrappers.size(); i++) &#123; list.add(orderWrappers.get(i).spi); &#125; return list; &#125; catch (Throwable t) &#123; RecordLog.error(\"[SpiLoader] ERROR: loadPrototypeInstanceListSorted failed\", t); t.printStackTrace(); return new ArrayList&lt;&gt;(); &#125;&#125; @1 SPI 发现并加载ProcessorSlot接口对象集合。通过[META-INF/services/com.alibaba.csp.sentinel.slotchain.ProcessorSlot]找到所有的调用链节点 @2 每个实现类上都有一个注解 @SpiOrder 取出注解上的值，用于后续的排序 @3 按 @SpiOrder 从小到大冒泡排序，将 spi 插入到 orderWrappers 中 @4 创建一个新的集合并将 spi 按顺序存入 在完成以上步骤后，调用链将被初始化成 顺序 节点 作用 下一个节点 1 DefaultProcessorSlotChain 第一个节点 NodeSelectorSlot 2 NodeSelectorSlot 创建当前Node ClusterBuilderSlot 3 ClusterBuilderSlot 创建全局Cluster节点 LogSlot 4 LogSlot 记录日志 StatisticSlot 5 StatisticSlot 统计各项指标 AuthoritySlot 6 AuthoritySlot 验证认证规则 SystemSlot 7 SystemSlot 验证系统指标（CPU等指标） FlowSlot 8 FlowSlot 验证限流指标 DegradeSlot 9 DegradeSlot 验证熔断指标 Null 责任链调用 NodeSelectorSlot 源码分析 12345678910111213141516171819DefaultNode node = map.get(context.getName());if (node == null) &#123; synchronized (this) &#123; node = map.get(context.getName()); if (node == null) &#123; node = new DefaultNode(resourceWrapper, null); HashMap&lt;String, DefaultNode&gt; cacheMap = new HashMap&lt;String, DefaultNode&gt;(map.size()); cacheMap.putAll(map); cacheMap.put(context.getName(), node); map = cacheMap; // Build invocation tree ((DefaultNode) context.getLastNode()).addChild(node); &#125; &#125;&#125;context.setCurNode(node);fireEntry(context, resourceWrapper, node, count, prioritized, args); NodeSelectorSlot 源码比较简单，主要逻辑就是根据 context 名找到一个对应的 Node 如果没有就创建一个，并标记为 context 的 当前 node ClusterBuilderSlot 源码分析 1234567891011121314if (clusterNode == null) &#123; synchronized (lock) &#123; if (clusterNode == null) &#123; // Create the cluster node. clusterNode = new ClusterNode(resourceWrapper.getName(), resourceWrapper.getResourceType()); HashMap&lt;ResourceWrapper, ClusterNode&gt; newMap = new HashMap&lt;&gt;(Math.max(clusterNodeMap.size(), 16)); newMap.putAll(clusterNodeMap); newMap.put(node.getId(), clusterNode); clusterNodeMap = newMap; &#125; &#125;&#125;node.setClusterNode(clusterNode); clusterNode 是相对资源唯一 因为一个资源只会有一个责任链，只有在初始化的时候需要进行缓存，所以这里只需要用 HashMap 用来存储这个 clusterNode， 并且在初始化的时候加上锁就可以了（后续只会读）。 LogSlot 源码分析 123456789101112try &#123; // @1 fireEntry(context, resourceWrapper, obj, count, prioritized, args);&#125; catch (BlockException e) &#123; // @2 EagleEyeLogUtil.log(resourceWrapper.getName(), e.getClass().getSimpleName(), e.getRuleLimitApp(), context.getOrigin(), count); throw e;&#125; catch (Throwable e) &#123; // @3 RecordLog.warn(\"Unexpected entry exception\", e);&#125; @1 先调用后面的责任链节点 @2 当后面的责任链节点触发 BlockException 异常后记录 Block 次数到鹰眼 @3 当后面的责任链触发其他异常后打出警告日志 StatisticSlot 源码分析 StatisticSlot 是 Sentinel 核心的一个类，统计各项指标用于后续的限流、熔断、系统保护等策略，接下来看下 Sentinel 是如何通过 StatisticSlot 进行指标统计的 12345678910// ...省略部分代码// Do some checking.// @1fireEntry(context, resourceWrapper, node, count, prioritized, args);// Request passed, add thread count and pass count.// @2node.increaseThreadNum();node.addPassRequest(count);// ...省略部分代码 @1 触发后面的责任链节点 @2 记录通过的线程数+1和通过请求 +count 这里的 node 就是第二个责任链节点 NodeSelectorSlot 创建的 DefaultNode 在分析源码前可以先简单了解下 Context、Entry、DefaultNode、ClusterNode 的关系 Context 每个线程是独享的，但是不同线程的 Context 可以使用同一个名字 EntranceNode 是根据 Context 名共享的，也就是说一个 Context.name 对应一个 EntranceNode。每次调用的时候都会创建，用于记录 Entry 是相对于每个 Context 独享的即是同一个 Context.name，包含了资源名、curNode（当前统计节点）、originNode（来源统计节点）等信息 DefaultNode 一个 Context.name 对应一个统计某资源调用链路上的指标 ClusterNode 一个资源对应一个，统计一个资源维度的指标 DefaultNode 和 ClusterNode 都继承至 StatisticNode 都包含两个 ArrayMetric 类型的字段 rollingCounterInSecond、rollingCounterInMinute 分别用于存储秒级和分钟级统计指标 而 ArrayMetric 类包含了一个 LeapArray&lt;MetricBucket&gt; 类型字段 data, data 中存放了一个 WindowWrap&lt;MetricBucket&gt; 元素的数组（滑动窗口）, 而这个数组就是各项指标最终存储的位置 1node.increaseThreadNum(); 这行代码其实就是对 StatisticNode.curThreadNum 进行自增操作 1234public void addPassRequest(int count) &#123; super.addPassRequest(count); this.clusterNode.addPassRequest(count);&#125; 添加通过的数量， 除了 DefaultNode 记录一次外，在 ClusterNode 上也需要记录一次【注意：ClusterNode 是按照资源维度统计的，这里指向的 ClusterNode 与同一资源不同 Context 指向的 ClusterNode 是同一个】。一个 Node 在调用了 addPassRequest 后发生了什么呢？ 1234public void addPassRequest(int count) &#123; rollingCounterInSecond.addPass(count); rollingCounterInMinute.addPass(count);&#125; 在以上代码可以看到 rollingCounterInSecond 、rollingCounterInMinute 两个字段，它们分别用来统计秒级指标和分钟级指标。而实际上这两个字段使用了滑动时间窗口数据结构用于存储指标。接下来看下 Sentinel 滑动窗口的设计: 时间滑动窗口主要用到的几个类有： ArrayMetric: 负责初始化时间滑动窗口和维护 LeapArray: 一个滑动时间窗口主体 WindowWrap: 一个时间窗口主体 LongAdder：指标统计的计数类 ArrayMetric 构造器： 123456789101112131415161718public ArrayMetric(int sampleCount, int intervalInMs) &#123; this.data = new OccupiableBucketLeapArray(sampleCount, intervalInMs);&#125;public ArrayMetric(int sampleCount, int intervalInMs, boolean enableOccupy) &#123; if (enableOccupy) &#123; this.data = new OccupiableBucketLeapArray(sampleCount, intervalInMs); &#125; else &#123; this.data = new BucketLeapArray(sampleCount, intervalInMs); &#125;&#125;/** * For unit test. */public ArrayMetric(LeapArray&lt;MetricBucket&gt; array) &#123; this.data = array;&#125; ArrayMetric 主要有三种构造器，最后一种只是用来跑单元测试使用，而前两种构造器主要为了初始化 data 字段。 从代码中我们可以看到 LeapArray 有两种实现方式 OccupiableBucketLeapArray 和 BucketLeapArray，而两种都继承至 LeapArray。 LeapArray 类图 LeapArray类图 LeapArray 类主要包含以下几个字段： int windowLengthInMs 一个时间窗口的长度，用毫秒表示 int sampleCount 表示用几个时间窗口统计 int intervalInMs 轮回时间，也就是所有时间窗口加起来的总时长 AtomicReferenceArray&lt;WindowWrap&lt;T&gt;&gt; array 时间窗口实例集合，数组的长度等于 sampleCount 那么我们在回头看下 rollingCounterInSecond 、rollingCounterInMinute 用到了哪种 LeapArray 1234567891011121314/** * SampleCountProperty.SAMPLE_COUNT = 2 * IntervalProperty.INTERVAL = 1000 * Holds statistics of the recent &#123;@code INTERVAL&#125; seconds. The &#123;@code INTERVAL&#125; is divided into time spans * by given &#123;@code sampleCount&#125;. */private transient volatile Metric rollingCounterInSecond = new ArrayMetric(SampleCountProperty.SAMPLE_COUNT, IntervalProperty.INTERVAL);/** * Holds statistics of the recent 60 seconds. The windowLengthInMs is deliberately set to 1000 milliseconds, * meaning each bucket per second, in this way we can get accurate statistics of each second. */private transient Metric rollingCounterInMinute = new ArrayMetric(60, 60 * 1000, false); 从上述代码中我们可以看到秒级统计初始化了一个 OccupiableBucketLeapArray 轮回时间为 1000ms 也就是 1s，分两个时间窗口每个各 500ms，而分钟级统计初始化了 BucketLeapArray 轮回时间为 60000ms 也就是 1Min ，分 60 个时间窗口每个窗口 1s。 12345// ArrayMetric.addPasspublic void addPass(int count) &#123; WindowWrap&lt;MetricBucket&gt; wrap = data.currentWindow(); wrap.value().addPass(count);&#125; 在添加通过指标前先获取到当前的时间窗口，再将通过数量统计到窗口对应的 MetricBucket 中，那么如何获取当前窗口呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public WindowWrap&lt;T&gt; currentWindow() &#123; return currentWindow(TimeUtil.currentTimeMillis());&#125;public WindowWrap&lt;T&gt; currentWindow(long timeMillis) &#123; if (timeMillis &lt; 0) &#123; return null; &#125; // private int calculateTimeIdx(long timeMillis) &#123; // long timeId = timeMillis / windowLengthInMs; // // Calculate current index so we can map the timestamp to the leap array. // return (int)(timeId % array.length()); // &#125; int idx = calculateTimeIdx(timeMillis); // Calculate current bucket start time. long windowStart = calculateWindowStart(timeMillis); /* * Get bucket item at given time from the array. * * (1) Bucket is absent, then just create a new bucket and CAS update to circular array. * (2) Bucket is up-to-date, then just return the bucket. * (3) Bucket is deprecated, then reset current bucket and clean all deprecated buckets. */ while (true) &#123; WindowWrap&lt;T&gt; old = array.get(idx); if (old == null) &#123; WindowWrap&lt;T&gt; window = new WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis)); if (array.compareAndSet(idx, null, window)) &#123; return window; &#125; else &#123; Thread.yield(); &#125; &#125; else if (windowStart == old.windowStart()) &#123; return old; &#125; else if (windowStart &gt; old.windowStart()) &#123; if (updateLock.tryLock()) &#123; try &#123; // Successfully get the update lock, now we reset the bucket. return resetWindowTo(old, windowStart); &#125; finally &#123; updateLock.unlock(); &#125; &#125; else &#123; // Contention failed, the thread will yield its time slice to wait for bucket available. Thread.yield(); &#125; &#125; else if (windowStart &lt; old.windowStart()) &#123; // Should not go through here, as the provided time is already behind. return new WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis)); &#125; &#125;&#125; 第一步首先获取到当前的时间戳毫秒，通过时间戳计算出时间窗口数组的下标。在计算下标时首先将当前时间戳除以单个窗口时长，计算出当前所在从0ms开始到现在的第几个窗，再对窗口数取模得出当前窗口的在数组中所在下标。从这里我们大概可以看出，这里数组中的时间窗口对象是反复使用的只是代表的时间不同了。 我们以秒级统计为例模拟计算下，当前时间戳为：1595495124658，按照 timeMillis / windowLengthInMs 可以得出 timeId 为 3190990249。 (int)(timeId % array.length()) 就是 3190990249 % 2 算出结果为 1，也就是说 1 下标位置的时间窗口是当前时间窗口。 第二步在计算出当前窗口所在下标后，需要计算出当前窗口的开始时间 timeMillis - timeMillis % windowLengthInMs，timeMillis % windowLengthInMs 表示当前窗口开始时间到当前时间的时长，所有当前时间减去时长即可得出当前窗口的开始时间，按上面的例子算出的结果就是 1595495124500 123456789WindowWrap&lt;T&gt; old = array.get(idx);if (old == null) &#123; WindowWrap&lt;T&gt; window = new WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis)); if (array.compareAndSet(idx, null, window)) &#123; return window; &#125; else &#123; Thread.yield(); &#125;&#125; 第三步根据下标取出我们的当前窗口的实例，如果实例还没有被创建过新建一个窗口实例并初始化同时通过 CAS 的方式更新到窗口数组中，如果更新失败让出 CPU 等待下次 CPU 执行本线程。 第四步如果下标位置已经存在一个窗口实例，并且窗口的开始时间跟本次窗口开始时间一致（同一个窗口），直接返回下标中的窗口 第五步如果当前窗口的开始时间大于下标窗口的开始时间，说明下标窗口已过期，需要重置数组下标中的窗口（把下标窗口的开始时间改完当前窗口时间，并将指标计数都置成 0 ） 第六步当前窗口时间小于下标窗口时间，重新实例化一个窗口（不太有这个可能，sentinel 内部实现了自己的时间戳） 在拿到当前时间所在窗口后，将当前的指标累加记录到 MetriBucket 中 MetriBucket 累加通过指标 * 12345678public void addPass(int n) &#123; add(MetricEvent.PASS, n);&#125;public MetricBucket add(MetricEvent event, long n) &#123; counters[event.ordinal()].add(n); return this;&#125; counters 是一个 LongAdder 类型的数组 MetricEvent 是指标类型，分别有：PASS 通过、BLOCK 阻塞、 EXCEPTION 异常、 SUCCESS 成功、 RT 平均响应时间、 OCCUPIED_PASS 通过未来的配额 counters[event.ordinal()].add(n) 在指定的指标计数器上累加计数 看到这里我们知道了 pass 指标是在资源通过 StatisticSlot 后几个节点的验证后立即进行指标计数，那么剩下的 BLOCK、 EXCEPTION、 SUCCESS、 RT、 OCCUPIED_PASS 这几个是在什么时候做记录的呢? BLOCK 统计 123456789101112131415161718192021...省略部分代码...&#125; catch (BlockException e) &#123; ...省略部分代码... // Add block count. node.increaseBlockQps(count); if (context.getCurEntry().getOriginNode() != null) &#123; context.getCurEntry().getOriginNode().increaseBlockQps(count); &#125; if (resourceWrapper.getEntryType() == EntryType.IN) &#123; // Add count for global inbound entry node for global statistics. Constants.ENTRY_NODE.increaseBlockQps(count); &#125; // Handle block event with registered entry callback handlers. for (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) &#123; handler.onBlocked(e, context, resourceWrapper, node, count, args); &#125; throw e;&#125; 在后续的责任链节点中（StatisticSlot 之后的节点），如果捕获到了阻塞异常，将对 DefaultNode、OriginNode、ENTRY_NODE 几个 node 进行指标累计。同样也是添加到当前窗口 MetricBucket 中不再进行过多描述 EXCEPTION 统计 12345678910111213141516171819try &#123; // Do some checking. fireEntry(context, resourceWrapper, node, count, prioritized, args); ...省略部分代码&#125; catch (Throwable e) &#123; // Unexpected error, set error to current entry. context.getCurEntry().setError(e); // This should not happen. node.increaseExceptionQps(count); if (context.getCurEntry().getOriginNode() != null) &#123; context.getCurEntry().getOriginNode().increaseExceptionQps(count); &#125; if (resourceWrapper.getEntryType() == EntryType.IN) &#123; Constants.ENTRY_NODE.increaseExceptionQps(count); &#125; throw e;&#125; 类似的 exception 统计在后续的责任链节点中（StatisticSlot 之后的节点），如果捕获到了异常，将对 DefaultNode、OriginNode、ENTRY_NODE 几个 node 进行指标累计。 除了 StatisticSlot 自动捕获异常外，在资源调用过程中如果出现了异常将通过调用 Tracer.trace(e) 手动统计异常指标 123456789101112131415public static void trace(Throwable e, int count) &#123; traceContext(e, count, ContextUtil.getContext());&#125;public static void traceContext(Throwable e, int count, Context context) &#123; if (!shouldTrace(e)) &#123; return; &#125; if (context == null || context instanceof NullContext) &#123; return; &#125; DefaultNode curNode = (DefaultNode)context.getCurNode(); traceExceptionToNode(e, count, context.getCurEntry(), curNode);&#125; 首先从线程变量中出去当前线程的 Context 在从中取出 DefaultNode 和 ClusterNode 并进行异常指标累计 SUCCESS、 RT 统计 平均响应时间和成功次数的统计是在资源退出的时候调用 entry.exit() 进行统计，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940// StatisticSlot#exit()public void exit(Context context, ResourceWrapper resourceWrapper, int count, Object... args) &#123; DefaultNode node = (DefaultNode)context.getCurNode(); if (context.getCurEntry().getError() == null) &#123; // Calculate response time (max RT is statisticMaxRt from SentinelConfig). long rt = TimeUtil.currentTimeMillis() - context.getCurEntry().getCreateTime(); int maxStatisticRt = SentinelConfig.statisticMaxRt(); if (rt &gt; maxStatisticRt) &#123; rt = maxStatisticRt; &#125; // Record response time and success count. node.addRtAndSuccess(rt, count); if (context.getCurEntry().getOriginNode() != null) &#123; context.getCurEntry().getOriginNode().addRtAndSuccess(rt, count); &#125; node.decreaseThreadNum(); if (context.getCurEntry().getOriginNode() != null) &#123; context.getCurEntry().getOriginNode().decreaseThreadNum(); &#125; if (resourceWrapper.getEntryType() == EntryType.IN) &#123; Constants.ENTRY_NODE.addRtAndSuccess(rt, count); Constants.ENTRY_NODE.decreaseThreadNum(); &#125; &#125; else &#123; // Error may happen. &#125; // Handle exit event with registered exit callback handlers. Collection&lt;ProcessorSlotExitCallback&gt; exitCallbacks = StatisticSlotCallbackRegistry.getExitCallbacks(); for (ProcessorSlotExitCallback handler : exitCallbacks) &#123; handler.onExit(context, resourceWrapper, count, args); &#125; fireExit(context, resourceWrapper, count);&#125; 退出也是责任链调用退出每个节点，这里直接跳过了大部分代码。退出统计大致流程如下： 获取得到当前时间戳和资源调用的时间，相减算出这次整个资源调用所花费的总时间 将总时间记录和成功次数累加记录当前窗口，本次总时间如果超过最大统计时间以最大统计时间作为本次统计时间 对 Node 扣减一次当前线程数 触发下一个责任链节点退出 LongAdder 源码分析 123456789101112131415161718192021public void add(long x) &#123; Cell[] as = cells; long b = base; long v; HashCode hc; Cell a; int n; if (cells != null || !casBase(base, b + x)) &#123; boolean uncontended = true; hc = threadHashCode.get() int h = hc.code; n = as.length; a = as[(n - 1) &amp; h] uncontended = a.cas(v = a.value, v + x) if (as == null || as.length &lt; 1 || a == null || !uncontended) &#123; retryUpdate(x, hc, uncontended); &#125; &#125;&#125; LongAdder 中有一个Cell数组用于存储数值，当高并发时对数组中某个值进行加法运算减少同一个数值并发。（+1） 或者 （+ -1） 123456789101112public long sum() &#123; long sum = base; Cell[] as = cells; if (as != null) &#123; int n = as.length; for (int i = 0; i &lt; n; ++i) &#123; Cell a = as[i]; if (a != null) &#123; sum += a.value; &#125; &#125; &#125; return sum;&#125; 取值时把 Cell 数组中所有元素的取出算总数 熔点判断 12345678910111213141516DegradeRuleManager.checkDegrade(resourceWrapper, context, node, count);public static void checkDegrade(ResourceWrapper resource, Context context, DefaultNode node, int count) throws BlockException &#123; Set&lt;DegradeRule&gt; rules = degradeRules.get(resource.getName()); if (rules == null) &#123; return; &#125; for (DegradeRule rule : rules) &#123; if (!rule.passCheck(context, node, count)) &#123; throw new DegradeException(rule.getLimitApp(), rule); &#125; &#125;&#125; 熔点的判断是由 DegradeRuleManager 管理。 DegradeRuleManager 会根据资源名取出所有的熔断规则，然后检查所有的规则如果触发其中一个直接抛出 DegradeException 异常触发熔断机制。 RT * 12345678910111213double rt = clusterNode.avgRt();if (rt &lt; this.count) &#123; passCount.set(0); // 计数，用于判断连续超 RT 多少次 return true;&#125;// Sentinel will degrade the service only if count exceeds.if (passCount.incrementAndGet() &lt; rtSlowRequestAmount) &#123; return true;&#125;...省略部分代码return false; 从 clusterNode 中计算出平均响应时间 如果平均响应时间小于规则设置时间，将统计连续超时计数器重置为0 如果平均响应时间大于规则设置时间，并且连续超时计数器超过了规则设置的大小，判为到达熔断点抛出熔断异常 统计平均 RT 的方法（秒级）： 取出所有窗口（秒级只定义了两个时间窗口）的 RT，并求总和 取出所有窗口（秒级只定义了两个时间窗口）的 success，并求总和 所有窗口的 RT 总和 除以 success 总和 得出平均RT 异常比例熔断也是类似的逻辑（秒级） 取出所有窗口的 exception 数求和，并除以一个间隔时间（秒为单位）【每秒总异常数】 取出所有窗口的 success 数求总和，并除以一个间隔时间（秒为单位）【每秒总退出成功数，包含了异常数】 取出所有窗口的 pass 总和 加上所有窗口 block 总数，并除以一个间隔时间（秒为单位）【算每秒总调用量】 如果每秒总调用量小于 minRequestAmount 判为未到达熔断点 如果每秒总异常数没有超过 minRequestAmount 判为未到达熔断点 每秒总退出成功数 / 每秒总异常数（异常比例）如果超过规则指定比例，判为到达熔断点抛出熔断异常 异常数就比例（分钟级） 取出所有窗口的 exception 数总和，判断如果超过规则配置数，抛出熔断异常 总结 Sentinel 通过责任链，触发节点创建、监控统计、日志、认证、系统限流、限流、熔断，因为Sentinl 是由 SPI 创建的责任链所以我们可以自定义链节点拿到指标根据自己的业务逻辑定义。 Sentinel 通过将所有的指标统计到时间窗口中，记录在 MetricBucket 类实例中","categories":[{"name":"java","slug":"java","permalink":"https://fantasylion.github.io/categories/java/"}],"tags":[{"name":"source","slug":"source","permalink":"https://fantasylion.github.io/tags/source/"}]},{"title":"ConcurrentHashMap 源码分析","slug":"ConcurrentHashMap-source-code","date":"2020-03-13T05:25:51.000Z","updated":"2020-03-13T05:25:51.000Z","comments":true,"path":"java/ConcurrentHashMap-source-code/","link":"","permalink":"https://fantasylion.github.io/java/ConcurrentHashMap-source-code/","excerpt":"","text":"众所周知 ConcurrentHashMap 是线程安全的一个 Map，那么他是如何实现线程安全的呢？以下就以 jdk1.8.0_172 的源码进行分析 put 方法源码，带注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); // 通过扰动函数获取计算出一个 hash int binCount = 0; // 默认为 0， 节点已经存在一个元素时 1表示元素 hash 大于等于0，2 表示存在红黑树 for (Node&lt;K,V&gt;[] tab = table;;) &#123; // 无限循环 Node&lt;K,V&gt; f; // 根据算出来的 i(index)取到的 node 节点 int n; // 当前 table 的长度 int i; // (n - 1) &amp; hash 应该是 index，这样的话每次长度可能是不一样的算出来的index能一致么（扩容后如何重新存放数据）？ int fh; // f 节点的hash值 if (tab == null || (n = tab.length) == 0) &#123; tab = initTable(); // 如果 table 不存在就初始化一个 &#125; else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 数组下标位置空缺，调用 unsafe 类的本地方法 getObjectVolatile 使用volatile的加载语义获取指定位置 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) // CAS 对比原值是否被改动，如果没有改动则替换原值 break; // no lock when adding to empty bin // CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，属于乐观锁 &#125; else if ((fh = f.hash) == MOVED) &#123; // hash for forwarding nodes tab = helpTransfer(tab, f); &#125; else &#123; // hash 冲突，当前 hash 对应数组下标已经有值了 V oldVal = null; synchronized ( f ) &#123; if ( tabAt(tab, i) == f ) &#123; // 在取一次数据确保数据在加锁前没有被修改过 if ( fh &gt;= 0 ) &#123; // hash 大于等于0（hash 什么情况下会小于0？） binCount = 1; for ( Node&lt;K,V&gt; e = f ;; ++binCount ) &#123; // 死循环并计数 K ek; // f 的key // 取出来的node key、hash跟传入进来的key是同一个没变 if ( e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) ) &#123; oldVal = e.val; if ( !onlyIfAbsent ) // 不是 只有在空缺时进行存入操作，直接把新值存进去 e.val = value; break; &#125; // 如果对应数组下标值key跟现在要存的key是不一样的 Node&lt;K,V&gt; pred = e; // e 就是f,根据算出来的 i(index)取到的 node 节点 if ((e = e.next) == null) &#123; // 下一个 node，如果是空的 pred.next = new Node&lt;K,V&gt;(hash, key, value, null); // 直接链表的下一个节点 break; &#125; &#125; &#125; else if ( f instanceof TreeBin ) &#123; // f 的 hash 小于 0 并且f 是一颗二叉树（树的hash肯定小于0么？） Node&lt;K,V&gt; p; binCount = 2; if ( ( p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value) ) != null ) &#123; // 找到一个节点或者新建一个节点 oldVal = p.val; if ( !onlyIfAbsent ) // 不是 只有在空缺时进行存入操作，直接把新值存进新树节点 p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; // 链表或者是二叉树 if (binCount &gt;= TREEIFY_THRESHOLD) // 链表的长度如果超过或等于8 treeifyBin(tab, i); // 将链表转换为二叉树 if (oldVal != null) return oldVal; // 如果原来有值则返回原来的值 break; &#125; &#125; &#125; addCount(1L, binCount); // 元素计数并判断是否需要扩容 return null;&#125; put 方法流程图 在 put 插入数据时存在这么几种情况： 数组 table 不存在 或者没有初始化长度（懒加载） 数据插入到哪个地址 期望插入的地址已经有数据了 在插入数据时如何避免有其他线程同时操作插入或者其他线程在执行扩容 存储数据已经存满了，该怎么办 下面针对以上几种情况进行分析 ConcurrentHashMap 时如何处理这些问题的 数组 table 不存在或者没有初始化长度 对于这个情况肯定是初始化一个数组就好了，在这里我们主要想分析的是如何初始化一个数组。对于初始化数组可能会存在的一个并发问题就是，在 A 线程初始化数组同时 B 线程也在执行初始化。 那 ConcurrentHashMap 是如何处理这个问题的。这里 ConcurrentHashMap 设置了一个 int 类型的属性 sizeCtl ，用于判断是否有其他线程在执行扩容或者初始化等调整大小的操作。先看下 sizeCtl 的注释： Table initialization and resizing control. When negative, the table is being initialized or resized: -1 for initialization, else -(1 + the number of active resizing threads). Otherwise, when table is null, holds the initial table size to use upon creation, or 0 for default. After initialization, holds the next element count value upon which to resize the table. 大致意思是 表初始化和大小调整控制。如果为负，则表将被初始化或调整大小：-1用于初始化， -（1 +活动的调整大小线程数）表示调整大小。否则，当table为null时，保留创建时要使用的初始表大小， 或者默认为0。 初始化之后，保留下一个要调整表大小的元素计数值。 代码中实现的逻辑是 siezeCtl 小于 0 的时候（也就是有其他线程对数组执行初始化或者调整大小），放弃 CPU 执行本线程，等待下次本线程抢到执行权（到时候在看还有没有其他线程在执行） 在确保只有本线程在执行初始化后，先对 sizeCtl 进行赋值 -1 准备开始初始化。在这里赋值时又有一个新的并发问题，如何保证在这一瞬间只有一个线程在执行赋值呢？这里 ConcurrentHashMap 调用了 Unsafe.compareAndSwapInt 方法去执行赋值操作，保证了本次赋值操作为原子操作。 那么这里可能又会产生一个新的疑问为什么 Unsafe.compareAndSwapInt 方法就是原子操作呢。翻看源码可以发现 compareAndSwapInt 是一个本地方法这类方法称为 CAS，实际最终调用的是一条 CPU 指令 compxchg。比较值是否被改动过，如果被改动过不做操作否则直接赋值数据，从操作中可以看出来这就是一个乐观锁的执行过程。 在上步加锁操作完成后，终于可以进入到初始化数组阶段了。到了这一步就很简单了，初始化一个 Node 数组，长度为默认 16 或者是 sizeCtl 有大于 0 的值就用 sizeCtl 做为数组长度。最后一个操作就是注释中提到的，保留下一个要调整表大小的元素计数值 （n - (n &gt;&gt;&gt; 2)）n 为最新长度。 数据插入到哪个地址，也就是定位索引，计算数组下标 12int hash = (key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)) &amp; 0x7fffffff; // 扰动函数int i = (n - 1) &amp; hash) 期望插入的地址已经有数据了，如何解决 Hash 冲突 插入的地址中已经有值，一般有两种情况 一种就是这个 key 已经存过一次了 另一种就是存在另外一个 key 跟当前 key 计算出的 hash 是一样的 第一种情况存的是同一个 key ，记录下老的数据，同时如果存入规则是允许数组下标对应元素非空缺时覆盖，则做覆盖操作否则不做操作。 第二种情况就是面试经常会问到的 hash 冲突。ConcurrentHashMap 使用了常用的解决 hash 冲突的方法，采用链表结构（HashMap、redis的字典都是采用链表解决 hash 冲突）。但是链表有一个问题，当链表越来越长时查询链表的效率会越来越低，所以 1.8 版本后 ConcurrentHashMap 引入红黑树来解决此问题。当链表长度超过 8 后将会尝试转换为红黑树。转换为红黑树有个前提是数组的长度必须大于 64，不然只是重新调整节点位置。 在插入数据时如何避免有其他线程同时操作插入或者其他线程在执行扩容 插入数据分为以下几种情况： 没有 hash 冲突，hash 对应的数组下标没有元素存在 存入的 key 与 hash 对应的元素是一样的 有 hash 冲突为链表结构数据 有 hash 冲突为红黑树结构数据 没有 hash 冲突，hash 对应的数组下标没有元素存在 与初始化方法类型用了 CAS 进行赋值 1U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v); 另外三种情况 存入的 key 与 hash 对应的元素是一样的 有 hash 冲突为链表结构数据 有 hash 冲突为红黑树结构数据 以上都是通过 synchronized 在数组中对应 Node 上加锁，以上三种情况同一时间只能有一个线程执行操作。 存储数据已经存满了，该怎么办，如何扩容 在解决以上问题是我们先考虑一个问题，如何判断数组已经满了？ 实际上 ConcurrentHashMap 并不会等到数组元素满了之后在进行扩容，有两种情况下需要进行扩容 一种是在新增节点后等到数组元素超过了装载系数0.75（也就是装满75%）后就会立即进行扩容 另一种是链表转换为红黑树时，如果数组长度没超过 64，将不会转换为红黑树而是进行扩容重新调整节点位置 以下为计数时候扩容代码加注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382/** * Adds to count, and if table is too small and not already * resizing, initiates transfer. If already resizing, helps * perform transfer if work is available. Rechecks occupancy * after a transfer to see if another resize is already needed * because resizings are lagging additions. * * @param x the count to add * @param check if &lt;0, don't check resize, if &lt;= 1 only check if uncontended * 默认为 0 ， 节点已经存在一个元素时 1表示元素 hash 大于等于0，2 表示存在红黑树 */ private final void addCount(long x, int check) &#123; CounterCell[] as; // 计数器集合，非空的时候是大小2的幂次方 // baseCount, Base counter value, used mainly when there is no contention, // but also as a fallback during table initialization races. Updated via CAS. long b； // baseCount long s; // 元素的总数 // as 非空说明出现过竞争（需要找到自己线程的计数器进行计数） // 计数器 +x 失败说明存在赋值竞争（需要通过计数器集合计数） if ( (as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x) ) &#123; CounterCell a; // 计数器 long v; // 当前线程的从 as 中随机取出的值 int m; // as 的最大下标 boolean uncontended = true; // 如果计数器数组是空的，需要初始化计数器数组 if (as == null || (m = as.length - 1) &lt; 0 || // 当前线程的计数（probe每个线程独享，类似于hash的作用用于寻址）如果是空的，需要初始化 (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || // 通过CAS给计数器 +x 如果失败需要进入 !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123; // 给cellvalue赋值 fullAddCount(x, uncontended); return; &#125; if (check &lt;= 1) return; // 统计计数 s = sumCount(); &#125; // 是否需要扩容 if (check &gt;= 0) &#123; Node&lt;K,V&gt;[] tab, nt; // 表长度 int n; // sizeCtrl int sc; // sizeCtl // -1 表示在初始化 // -(1+在扩容的线程数) 表示在扩容 // 如果表是 null, sizeCtl 的值就表示需要初始化的大小，默认是 0 // 在初始化完成之后，sizeCtl 的值则表示下一个扩容的阈值（n-(n &gt;&gt;&gt; 2) 等于 n * 0.75 向上取整 // 元素总数超过 sizeCtrl，并且表不为Null并且 表的长度没超过最大容量 while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; int rs = resizeStamp(n); // 负数表示在初始化（-1）或者在扩容（-1 + -number of Threads）, 这里判断是否有其他线程正在进行扩容 if (sc &lt; 0) &#123; // 判断扩容是否结束，结束则中断循环 if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; // sizeCtrl +1 表示扩容线程 +1 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); // 触发扩容（第一个扩容的线程） // 高16位是一个对n的数据校验的标志位，低16位表示参与扩容操作的线程个数 + 1。 &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) &#123; transfer(tab, null); &#125; // 统计元素总数 s = sumCount(); &#125; &#125; &#125; private final void fullAddCount(long x, boolean wasUncontended) &#123; int h; if ((h = ThreadLocalRandom.getProbe()) == 0) &#123; ThreadLocalRandom.localInit(); // force initialization h = ThreadLocalRandom.getProbe(); wasUncontended = true; &#125; boolean collide = false; // True if last slot nonempty for (;;) &#123; CounterCell[] as; // 计数器数组 CounterCell a; int n; // 计数器数组长度 long v; // 计数器数组不为空，已经初始化过了（存在以下两种情况） // 一、最开始没初始化，当前线程进来一瞬间被其他线程初始化了 // 二、已经初始化了，但是在上一步当前线程给自己在计数器数组中的值加X时候有冲突导致失败了 if ((as = counterCells) != null &amp;&amp; (n = as.length) &gt; 0) &#123; // 当前线程在计数器数组中没有值 if ((a = as[(n - 1) &amp; h]) == null) &#123; // 查看锁状态是否被锁住，（cellsBusy 是在计数器数组扩容或者创建计数器时用的锁） if (cellsBusy == 0) &#123; // Try to attach new Cell CounterCell r = new CounterCell(x); // Optimistic create // 给 cellsBusy 上锁，准备初始化计数器 if (cellsBusy == 0 &amp;&amp; U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123; boolean created = false; try &#123; // Recheck under lock CounterCell[] rs; int m, j; // 进入到锁里面后，重新检查下计数器数组，确保当前线程计数器没有初始化过 if ((rs = counterCells) != null &amp;&amp; (m = rs.length) &gt; 0 &amp;&amp; rs[j = (m - 1) &amp; h] == null) &#123; // 初始化当前线程的计数器 rs[j] = r; created = true; &#125; &#125; finally &#123; // 释放锁 cellsBusy = 0; &#125; // 如果线程成功初始化计数器，则结束，否则继续回头起点重新初始化计数器 if (created) break; continue; // Slot is now non-empty &#125; &#125; collide = false; &#125; else if (!wasUncontended) // CAS already known to fail wasUncontended = true; // Continue after rehash // 当前线程在计数器数组中有值，直接通过 cas 加x else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)) break; // 当前计数器数组长度超过了 CPU 的数量，或者计数器被修改了 else if (counterCells != as || n &gt;= NCPU) collide = false; // At max size or stale else if (!collide) collide = true; // 对计数器数组进行扩容 else if (cellsBusy == 0 &amp;&amp; U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123; try &#123; if (counterCells == as) &#123;// Expand table unless stale CounterCell[] rs = new CounterCell[n &lt;&lt; 1]; for (int i = 0; i &lt; n; ++i) rs[i] = as[i]; counterCells = rs; &#125; &#125; finally &#123; cellsBusy = 0; &#125; collide = false; continue; // Retry with expanded table &#125; // 重新计算hash h = ThreadLocalRandom.advanceProbe(h); &#125; // 计数器数组没被初始化过，通过cellsBusy 上锁 准备开始初始化计数器数组 else if (cellsBusy == 0 &amp;&amp; counterCells == as &amp;&amp; U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) &#123; boolean init = false; try &#123; // Initialize table if (counterCells == as) &#123; CounterCell[] rs = new CounterCell[2]; rs[h &amp; 1] = new CounterCell(x); counterCells = rs; init = true; &#125; &#125; finally &#123; cellsBusy = 0; &#125; if (init) break; &#125; // 初始化计数器数组上锁失败，尝试直接在 basecount 中计数 else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x)) break; // Fall back on using base &#125; &#125; /** * Moves and/or copies the nodes in each bin to new table. See * above for explanation. */ private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length; // 原表长度 int stride; // 一次操作多少条数据 // 根据 CPU 数量来划分一次操作多少条数据，最小是 16 条 if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) // MIN_TRANSFER_STRIDE = 16 stride = MIN_TRANSFER_STRIDE; // subdivide range if (nextTab == null) &#123; // initiating try &#123; @SuppressWarnings(\"unchecked\") // n &lt;&lt; 1 就是 n * 2，表示原来的两倍 Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; &#125; nextTable = nextTab; transferIndex = n; // 一直指向最小边界 &#125; int nextn = nextTab.length; // A node inserted at head of bins during transfer operations. ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); boolean advance = true; boolean finishing = false; // to ensure sweep before committing nextTab // i 指向最大边界 bound 指向最小边界 for (int i = 0, bound = 0;;) &#123; Node&lt;K,V&gt; f; int fh; // 给当前线程分配任务（移动指针指向一个操作范围） while (advance) &#123; int nextIndex; // 过度用的临时存储变量 int nextBound; // // --i &gt;= bound 表示 或者 任务已经完成 if (--i &gt;= bound || finishing) &#123; advance = false; // 一个任务的指针如果小于0 表示任务分配完毕 &#125; else if ((nextIndex = transferIndex) &lt;= 0) &#123; i = -1; advance = false; // 分配下一个迁移任务范围 &#125; else if (U.compareAndSwapInt(this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound; i = nextIndex - 1; advance = false; &#125; &#125; // i &lt; 0 任务完成 // i &gt;= n 任务完成后 // i + n &gt;= nextn 任务完成后 if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; // 如果所有任务都已经完成，重置数据 if (finishing) &#123; nextTable = null; table = nextTab; // 设置下一个阈值 sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; &#125; // 当前线程数减一 if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; finishing = advance = true; i = n; // recheck before commit &#125; &#125; // 如果i (最大边界) 的值是空的不需要迁移，直接插入 forwardNode 告知其他线程这块已经处理过了 else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); // 数据已经拷贝到新表中 else if ((fh = f.hash) == MOVED) advance = true; // already processed else &#123; // f 节点加锁 synchronized (f) &#123; // 加锁后再次确认数据没有被修改过 if (tabAt(tab, i) == f) &#123; Node&lt;K,V&gt; ln; // 用来存放保留原位置的链表 Node&lt;K,V&gt; hn; // 用来存放迁移到 原位置+n 的链表 // 节点 hash code 不为负数表示为链表 if (fh &gt;= 0) &#123; // fh 为需要迁移节点hash, n 为原表长度 // f 为需要迁移起始节点 // hash &amp; n 只会计算出 n 或者 0 值 // n 为原表长度为2的幂次方，所以二进制肯定是 一个1后面带几个零，如16： 10000 // 任何值 &amp; 上 10000 只会有两个结果 10000 或者 0 // 计算结果为n的，直接迁移到 原位置index + n 的位置 // 计算结果为0的，保留在原位置 // 为什么这么做呢？后面在讲... int runBit = fh &amp; n; Node&lt;K,V&gt; lastRun = f; // 循环遍历找到链表最后几个连续的同一类型节点（都保留原位置的或者都要迁移到 原位置+n 的节点） for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n; // 找到链表最后几个连续同一类型节点中的头节点 if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; // 如果本次找到的连续节点是保留原位置的放到 ln 链表 if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; // 如果本次找到的连续节点是迁移到 原位置+n 位置的放到 hn 链表 else &#123; hn = lastRun; ln = null; &#125; // 继续把其他的节点进行分类 // 保留原位置的插入到 ln 链表起始位置 // 迁移到 原位置+n 的插入到 hn 链表起始位置 // 这里都是插入到起始位置，所以链表不会跟 1.7 jdk 一样发生链表倒置问题 for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); &#125; // 迁移数据 setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); // 原表原位置插上 forwardNode 节点表示已经迁移完毕 setTabAt(tab, i, fwd); advance = true; &#125; // 如果已经被转成红黑树了 else if (f instanceof TreeBin) &#123; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; // 需要迁移的节点，转成树类型 TreeNode&lt;K,V&gt; lo = null, loTail = null; // TreeNode&lt;K,V&gt; hi = null, hiTail = null; // int lc = 0, hc = 0; // TreeNode 本身也就是链表 // 跟链表一样先分成两类，然后一起迁移 for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(h, e.key, e.val, null, null); // 保持原位节点 if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; &#125; // 迁移到 原位+n 节点 else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; // 元素数量没有超过6，退化成链表 ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : // new TreeBin&lt;K,V&gt;(lo) 会把lo TreeNode 链表重新构建成一个新的红黑树 (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; &#125; &#125; &#125; &#125; &#125; 参考资料： ConcurrentHashMap: https://www.cnblogs.com/zyrblog/p/9881958.html Map: https://sylvanassun.github.io/2018/03/16/2018-03-16-map_family/#more cmpxchg：http://heather.cs.ucdavis.edu/~matloff/50/PLN/lock.pdf CAS1：https://juejin.im/post/5a73cbbff265da4e807783f5 CAS2：https://liuzhengyang.github.io/2017/05/11/cas/ CAS3：https://zhuanlan.zhihu.com/p/34556594","categories":[{"name":"java","slug":"java","permalink":"https://fantasylion.github.io/categories/java/"}],"tags":[{"name":"source","slug":"source","permalink":"https://fantasylion.github.io/tags/source/"}]},{"title":"Airflow 使用 Celery 时，如何添加 Celery 配置","slug":"2020-01-07-adding-extra-celery-configs-to-airflow","date":"2020-01-06T16:00:00.000Z","updated":"2020-01-06T16:00:00.000Z","comments":true,"path":"tool/2020-01-07-adding-extra-celery-configs-to-airflow/","link":"","permalink":"https://fantasylion.github.io/tool/2020-01-07-adding-extra-celery-configs-to-airflow/","excerpt":"Airflow 使用 Celery 时，如何添加 Celery 配置","text":"背景 前段时间我选用了 Airflow 对 wms 进行数据归档，在运行一段时间后，经常发现会报以下错误： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[2020-01-07 14:41:34,465: WARNING&#x2F;ForkPoolWorker-5] Failed operation _store_result. Retrying 2 more times.Traceback (most recent call last): File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;sqlalchemy&#x2F;engine&#x2F;base.py&quot;, line 1245, in _execute_context self.dialect.do_execute( File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;sqlalchemy&#x2F;engine&#x2F;default.py&quot;, line 581, in do_execute cursor.execute(statement, parameters) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;MySQLdb&#x2F;cursors.py&quot;, line 255, in execute self.errorhandler(self, exc, value) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;MySQLdb&#x2F;connections.py&quot;, line 50, in defaulterrorhandler raise errorvalue File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;MySQLdb&#x2F;cursors.py&quot;, line 252, in execute res &#x3D; self._query(query) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;MySQLdb&#x2F;cursors.py&quot;, line 378, in _query db.query(q) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;MySQLdb&#x2F;connections.py&quot;, line 280, in query _mysql.connection.query(self, query)_mysql_exceptions.OperationalError: (2006, &#39;MySQL server has gone away&#39;)The above exception was the direct cause of the following exception:Traceback (most recent call last): File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;celery&#x2F;backends&#x2F;database&#x2F;__init__.py&quot;, line 53, in _inner return fun(*args, **kwargs) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;celery&#x2F;backends&#x2F;database&#x2F;__init__.py&quot;, line 107, in _store_result task &#x3D; list(session.query(Task).filter(Task.task_id &#x3D;&#x3D; task_id)) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;sqlalchemy&#x2F;orm&#x2F;query.py&quot;, line 3367, in __iter__ return self._execute_and_instances(context) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;sqlalchemy&#x2F;orm&#x2F;query.py&quot;, line 3392, in _execute_and_instances result &#x3D; conn.execute(querycontext.statement, self._params) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;sqlalchemy&#x2F;engine&#x2F;base.py&quot;, line 982, in execute return meth(self, multiparams, params) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;sqlalchemy&#x2F;sql&#x2F;elements.py&quot;, line 287, in _execute_on_connection return connection._execute_clauseelement(self, multiparams, params) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;sqlalchemy&#x2F;engine&#x2F;base.py&quot;, line 1095, in _execute_clauseelement ret &#x3D; self._execute_context( File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;sqlalchemy&#x2F;engine&#x2F;base.py&quot;, line 1249, in _execute_context self._handle_dbapi_exception( File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;sqlalchemy&#x2F;engine&#x2F;base.py&quot;, line 1476, in _handle_dbapi_exception util.raise_from_cause(sqlalchemy_exception, exc_info) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;sqlalchemy&#x2F;util&#x2F;compat.py&quot;, line 398, in raise_from_cause reraise(type(exception), exception, tb&#x3D;exc_tb, cause&#x3D;cause) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;sqlalchemy&#x2F;util&#x2F;compat.py&quot;, line 152, in reraise raise value.with_traceback(tb) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;sqlalchemy&#x2F;engine&#x2F;base.py&quot;, line 1245, in _execute_context self.dialect.do_execute( File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;sqlalchemy&#x2F;engine&#x2F;default.py&quot;, line 581, in do_execute cursor.execute(statement, parameters) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;MySQLdb&#x2F;cursors.py&quot;, line 255, in execute self.errorhandler(self, exc, value) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;MySQLdb&#x2F;connections.py&quot;, line 50, in defaulterrorhandler raise errorvalue File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;MySQLdb&#x2F;cursors.py&quot;, line 252, in execute res &#x3D; self._query(query) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;MySQLdb&#x2F;cursors.py&quot;, line 378, in _query db.query(q) File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;MySQLdb&#x2F;connections.py&quot;, line 280, in query _mysql.connection.query(self, query)sqlalchemy.exc.OperationalError: (_mysql_exceptions.OperationalError) (2006, &#39;MySQL server has gone away&#39;)[SQL: SELECT celery_taskmeta.id AS celery_taskmeta_id, celery_taskmeta.task_id AS celery_taskmeta_task_id, celery_taskmeta.status AS celery_taskmeta_status, celery_taskmeta.result AS celery_taskmeta_result, celery_taskmeta.date_done AS celery_taskmeta_date_done, celery_taskmeta.traceback AS celery_taskmeta_traceback FROM celery_taskmeta WHERE celery_taskmeta.task_id &#x3D; %s][parameters: (&#39;e909b916-4284-47c4-bc5b-321bc32eb9f9&#39;,)](Background on this error at: http:&#x2F;&#x2F;sqlalche.me&#x2F;e&#x2F;e3q8) 解决过程 查了下资料一般情况下数据库服务器断开连接后，被连接池未收回将会导致以下错误： 1MySQL server has gone away 所以看了下 sqlalchemy 的配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849sql_alchemy_pool_enabled &#x3D; True# The SqlAlchemy pool size is the maximum number of database connections# in the pool. 0 indicates no limit.sql_alchemy_pool_size &#x3D; 5# The maximum overflow size of the pool.# When the number of checked-out connections reaches the size set in pool_size,# additional connections will be returned up to this limit.# When those additional connections are returned to the pool, they are disconnected and discarded.# It follows then that the total number of simultaneous connections the pool will allow is pool_size + max_overflow,# and the total number of &quot;sleeping&quot; connections the pool will allow is pool_size.# max_overflow can be set to -1 to indicate no overflow limit;# no limit will be placed on the total number of concurrent connections. Defaults to 10.sql_alchemy_max_overflow &#x3D; 10# The SqlAlchemy pool recycle is the number of seconds a connection# can be idle in the pool before it is invalidated. This config does# not apply to sqlite. If the number of DB connections is ever exceeded,# a lower config value will allow the system to recover faster.sql_alchemy_pool_recycle &#x3D; 1800# Check connection at the start of each connection pool checkout.# Typically, this is a simple statement like “SELECT 1”.# More information here: https:&#x2F;&#x2F;docs.sqlalchemy.org&#x2F;en&#x2F;13&#x2F;core&#x2F;pooling.html#disconnect-handling-pessimisticsql_alchemy_pool_pre_ping &#x3D; Truesql_alchemy_pool_size &#x3D; 5# The maximum overflow size of the pool.# When the number of checked-out connections reaches the size set in pool_size,# additional connections will be returned up to this limit.# When those additional connections are returned to the pool, they are disconnected and discarded.# It follows then that the total number of simultaneous connections the pool will allow is pool_size + max_overflow,# and the total number of &quot;sleeping&quot; connections the pool will allow is pool_size.# max_overflow can be set to -1 to indicate no overflow limit;# no limit will be placed on the total number of concurrent connections. Defaults to 10.sql_alchemy_max_overflow &#x3D; 10# The SqlAlchemy pool recycle is the number of seconds a connection# can be idle in the pool before it is invalidated. This config does# not apply to sqlite. If the number of DB connections is ever exceeded,# a lower config value will allow the system to recover faster.sql_alchemy_pool_recycle &#x3D; 1800# Check connection at the start of each connection pool checkout.# Typically, this is a simple statement like “SELECT 1”.# More information here: https:&#x2F;&#x2F;docs.sqlalchemy.org&#x2F;en&#x2F;13&#x2F;core&#x2F;pooling.html#disconnect-handling-pessimisticsql_alchemy_pool_pre_ping &#x3D; True 该配的都配置上了，因为我们的任务是一天跑一次，查了下数据库变量 waits_timeout 是 28800 ，所以直接改成25个小时。 到了第二天发现还是报这个错，很奇怪该配的都配上了，到底是哪里的问题？ 仔细翻下报错日志： 12File &quot;&#x2F;usr&#x2F;local&#x2F;python38&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;celery&#x2F;backends&#x2F;database&#x2F;__init__.py&quot;, line 107, in _store_result task &#x3D; list(session.query(Task).filter(Task.task_id &#x3D;&#x3D; task_id)) 难道 Airflow 的 sqlalchemy 配置对 celery 不生效？ 翻阅下源码发现果然 Airflow 配置的 sqlalchemy 只对 Airflow 生效 123app &#x3D; Celery( conf.get(&#39;celery&#39;, &#39;CELERY_APP_NAME&#39;), config_source&#x3D;celery_configuration) 在继续翻阅 Celery 文档看有没有办法配置 database_short_lived_sessions Default: Disabled by default. Short lived sessions are disabled by default. If enabled they can drastically reduce performance, especially on systems processing lots of tasks. This option is useful on low-traffic workers that experience errors as a result of cached database connections going stale through inactivity. For example, intermittent errors like (OperationalError) (2006, ‘MySQL server has gone away’) can be fixed by enabling short lived sessions. This option only affects the database backend. 文档告知通过database_short_lived_sessions 参数就可以避免这个问题，但是新的问题又来了，如何在 Airflow 中配置额外的 Celery 配置呢？ 解决方案 找到以下文件拷贝到 DAGS 目录下，重新命名为 my_celery_config 随便起 1Python&#x2F;Python37&#x2F;site-packages&#x2F;airflow&#x2F;config_templates&#x2F;default_celery.py 修改 Airflow.cfg 配置 找到 celery_config_options 将配置改为 刚才起的名字 1celery_config_options &#x3D; my_celery_config.DEFAULT_CELERY_CONFIG 在 my_celery_config 文件中的 DEFAULT_CELERY_CONFIG dict 中就可以随便加自己需要的 Celery 配置","categories":[{"name":"tool","slug":"tool","permalink":"https://fantasylion.github.io/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://fantasylion.github.io/tags/tool/"}]},{"title":"Windows 本地搭建 Airflow 开发环境","slug":"2019-11-25-airflow-remote-dev","date":"2020-01-06T16:00:00.000Z","updated":"2020-01-06T16:00:00.000Z","comments":true,"path":"tool/2019-11-25-airflow-remote-dev/","link":"","permalink":"https://fantasylion.github.io/tool/2019-11-25-airflow-remote-dev/","excerpt":"Windows 本地搭建 Airflow 开发环境","text":"背景 因为 Airflow 无法在windows搭建开发环境导致开发过程比较麻烦。下面提供一个方法用来在windows环境中debug。以下方法的前提是在 Pycharm IDE中开发 第一步：本地开启 debug 端口 第二步：给远程服务器安装pydevd模块 图2中的断点代码拷贝到服务器后无法立即生效还会报错，因为缺少了模块。 在 pycharm 安装目录下找到 pycharm-debug.egg 文件，放到远程服务器python目录下我放到了site-package目录下，pycharm-debug-py3k.egg 提供给python3版本使用，我这边是2.7用第一个即可 完成以上步骤可以在服务器python中执行下 1&gt;&gt;&gt; import pydevd 如果没有报错说明安装成功 第三步：开始debug 点击右上角小虫启动，console 中出现 waiting 后说明开始等待远程的debug请求了 运行远程服务器的代码后，本地对应代码将进入对应代码段 参考资料： pycharm官网远程debug教程 Linux和Mac搭建开发环境资料： https://github.com/apache/airflow/blob/master/LOCAL_VIRTUALENV.rst https://github.com/apache/airflow/blob/master/BREEZE.rst#testing-and-debugging-in-breeze","categories":[{"name":"tool","slug":"tool","permalink":"https://fantasylion.github.io/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://fantasylion.github.io/tags/tool/"}]},{"title":"如何使用 Enterprise Architect 画 UML","slug":"2019-01-17-How-to-use-EA","date":"2019-01-16T16:00:00.000Z","updated":"2019-01-16T16:00:00.000Z","comments":true,"path":"Tools/2019-01-17-How-to-use-EA/","link":"","permalink":"https://fantasylion.github.io/Tools/2019-01-17-How-to-use-EA/","excerpt":"EA 的英文全称叫 Enterprise Architect，是由澳大利亚公司 Sparx Systems 开发的一款基于 OMG UML 的可视化模型与设计工具，提供了对软件系统的设计和构建、业务流程建模和基于领域建模的支持，被企业和组织不仅应用于对系统的建模，还用于推进模型在整个应用程序开发周期中实现。","text":"重识 EA (Enterprise Architect) 公司使用的 OMS 是从外面买过来后进行二次开发的，而对方给到的技术文档不够全面，有很大部分的业务细节需要自己看代码梳理。想起来之前 IBM Developer 看过一篇关于 Tomcat 原理的文章，文章里面用到了很多建模语言（UML）去描述代码逻辑结构。这不仅看起来高大上而且逻辑清晰易懂，就想着将上学那会学的 UML 重新捡起来，学着用 UML 去梳理代码逻辑。 记得上学那会写 UML 的工具叫 EA ，这两天我就给扒拉出来重新装上又学了一遍。下面就讲下 EA 的使用 EA 简介 EA 的英文全称叫 Enterprise Architect，是由澳大利亚公司 Sparx Systems 开发的一款基于 OMG UML 的可视化模型与设计工具，提供了对软件系统的设计和构建、业务流程建模和基于领域建模的支持，被企业和组织不仅应用于对系统的建模，还用于推进模型在整个应用程序开发周期中实现。不是我们玩游戏的那个 EA 哦！在官网的文档中还有看到 EA 可以跟 Eclipse 做无缝的对接，很可惜的是没有找到有跟 IDEA 相关的。 EA 安装下载 安装 EA 其实很简单，Windows 系统在官网下载下来后直接下一步下一步即可。但是 EA 是需要付费的，当然你也可以选择教学版的或者免费试用30天，这里我给大家提供一个密钥： 1834735814236 这个 Key 目前本人在使用，我的 EA 版本是 14.0.1422。 我之前安装的时候被我不小心跳过了输入密钥的环节，因为英文不好后来找输入密钥的窗口找了很久，这里记录下方便遇到跟我一样问题的朋友参考。 点击左上角Start --&gt; Help --&gt; Register and Manage Your License Keys --&gt; 在输入框中输入 key。 在弹出的输入框中输入key，我这里窗口 title 显示 Upgrade Key 应该是因为我已经注册过 key 的原因 EA 的使用 既然 EA 是 UML 的可视化模型与设计工具，当然是支持 UML 常见的模型，但是目前我也是刚开始使用 UML 这里只记录下怎么画用例模型中的时序图。 常见 UML 模型 业务过程模型 用例模型 动态模型 逻辑模型 组件模型 物理模型 在 EA 安装完成后运行 EA，首先看到的应该是一张 Start Page。 如上图所示，正常打开后分这么几个区域，最上方显示的是各种功能选项下方一般有多个区域可以通过拖动自定义摆放位置。 图中最左边的 Toolbox 是模型的工具栏主要放置当前编辑模型的组件，中间大块的是编辑区以选项卡的方式呈现可以在最下方点击不同选项卡切换编辑区，右边数来第二个区域显示了三个模块 Diagram Properties 、 Resources 、 Project Browser 也是通过选项卡的方式呈现，最后一个 Portals 可以显示指南书、学习、状态查询… 创建一个项目 点击编辑区 Start Page 选项卡中的 New File 选项，在选择项目目录输入文件名点击保存。或者在最上方区域的左上角点击 EA 图标后点击 New Project 创建一个新的项目。 在项目创建成功后开始创建 Model ，点击最上方区域右下角栅格式的图标 -&gt; 点击 Add Model 后 -&gt; 在编辑区选择 UML 并选择相应模型（这演示我选择的是时序图 Sequence Diagrams -&gt; Starter Sequence Diagram） -&gt; 点击 Create Pattern(s) 步骤如下图所示 下图为编辑区操作，这里 Create Pattern(s) 按钮在图的左下角忘记圈出来了 创建 Model 成功后在 Project Browser 中可以看到已经成功创建了一个 Model (Starter Sequence Diagram)，第三级的为当前包含的组件，点击下图中画红圈选项在编辑区中将会打开 Starter Sequence Diagram 开始编辑 编辑区如下图所示 如何编辑设计模型 将 ToolBox 中的相应的组件拖拽到编辑区中即可生成，在编辑区双击相应的主键将会弹出组件的属性框，在属性框可以修改组件名称、类型、结构等属性，这里就不做详细的记录。 如何将编辑完的模型导出图片 点击最上方区域的 Publish 选项 -&gt; Image -&gt; Save to File 写好图片名和格式保存到相应目录中，或者选择 Save to clipboard 保存到粘贴板中。 如下图： 最后展示下最终的成果","categories":[{"name":"Tools","slug":"Tools","permalink":"https://fantasylion.github.io/categories/Tools/"}],"tags":[{"name":"uml","slug":"uml","permalink":"https://fantasylion.github.io/tags/uml/"}]},{"title":"zookeeper 应用指南中文版","slug":"2018-03-20-zookeeper-guide-chinese","date":"2018-03-19T16:00:00.000Z","updated":"2018-03-19T16:00:00.000Z","comments":true,"path":"zookeeper/2018-03-20-zookeeper-guide-chinese/","link":"","permalink":"https://fantasylion.github.io/zookeeper/2018-03-20-zookeeper-guide-chinese/","excerpt":"使用ZooKeeper开始分布式应用","text":"[TOC] 目录 介绍 本文档适合于希望利用ZooKeeper创建协调服务分布式应用程序的开发人员。本文包含了概念和实例。 文档的前四部分对各种ZooKeeper概念进行了深入的讨论。它可以让你更深入的了解ZooKeeper是怎么运行的和怎么去使用它。这里不包含ZooKeeper的源码，但是这里详细描述了分布式计算相关的问题。这四部分分别为： ZooKeeper 数据模型 ZooKeeper 会话 ZooKeeper 观察者（订阅者） 一致性保证 以下为后四部分描述了编程设计的信息： 构建模块：ZooKeeper 操作指南 绑定 程序结构和一些简单的案例 陷阱：常见的问题和故障排除 本文后提供一份附件包含了一些其他关于 ZooKeeper 的信息。 本文中大部分信息都是作为独立参考资料编写的。在你开始写第一个ZooKeeper应用之前，你最好先阅读下这两部分文章，ZooKeeper 数据模型和 ZooKeeper 基础操作。当然简单示例对你理解 ZooKeeper 客户端应用也有很大帮助。 ZooKeeper 数据模型 ZooKeeper 使用分级命名规则，看起来就像一个分布式文件系统。它们唯一的区别是 ZooKeeper 命名空间中的每个节点都可以拥有相关数据和子节点。就像是一个文件系统它允许一个文件可以当做目录来用。节点的路径可以用 canonical、绝对路径、斜线路径表示；这里不可以使用相对路径。任何unicode字符都可以在路径中被使用但是需要遵从一下规则： null 字符(\\u0000)不能被用在路径名上。（这是因为使用 C 编译导致的） 以下几个字符不允许使用：\\ud800 -uF8FFF, \\uFFF0 - uFFFF。 “.” 字符可以被用在路径名上，但是 “.” 和 “..” 不能用于单独指示一个节点，因为ZooKeeper不能使用相对路径。后面这几个路径被认为是无效的：&quot;/a/b/./c&quot; or &quot;/a/b/../c&quot;。 zookeeper 是系统保留字符，不允许被使用。 ZNodes ZooKeeper 树中的任何一个节点都依赖于 ZNode。ZNode 维护一个统计结构，这个结构包含了修改数据和修改ACL的版本号。当然这个统计结构也有一个时间戳。这个版本号和时间戳一起使用可以用来 ZooKeeper 去验证缓存和定位更新。每当有一个znode的数据被修改，这个版本号就会增加一个值。比如：当客户端检索数据的时候它也会收到这个数据的版本号。当一个客户端执行修改和删除的时候，它必须提供一个修改后的节点数据的版本号。如果这个版本号跟实际的数据版本号不匹配，本次的更新将会失败。（这个行为可以被覆盖。详情请看…） Note 在分布式应用引擎上，节点可以是指一台主机、一个服务、集群中的某个成员、一个客户端进程等等。在 ZooKeeper 文档中，ZNodes 指一个数据节点。Servers 指启动ZooKeeper服务的服务器；quorum peers 指服务集群； 客户端指任何一台主机或者使用 ZooKeeper 服务的进程 znode 是 ZooKeeper 的主要概念程序员需要认真了解。Znodes有几个特性值得在此提及： ZooKeepr 监控 客户端可以在 znodes 上设置监控。如果被监控节点有修改，znode 将触发监控然后再清除这个监控。当监控被触发后，ZooKeeper 将会发送通知到客户端。更多关于监控可以在 ZooKeeper 监控 部分找到。 数据访问 在一个命名空间下每个 Znode 数据存储的读写都是原子化的。读取操作将获取到所有这个 znode 相关的字节数据，写入操作将会替换所有数据。每个节点都会有一个访问控制列表(ACL)用于限制谁可以做什么。 ZooKeeper 并不是设计用来当做数据库或者大量的数据存储。相反，它管理协调数据。这个数据可以通过一个 form 表单配置、状态信息、集合点等形式出现。各种形式的协调数据的共同特点是它们相对较小：以千字节为单位。ZooKeeper的客户端还有服务实例都要检查并确保每个 Znode 的数据要小于1M，并且每个数据都必须小于平均值。 操作相对较大的数据会比其他数据时间要长，并且由于需要花费额外多的时间在网络传输上和存入存储媒介中会导致操作延时。如果真的需要比较大的数据存储，通常采用大容量的存储系统去处理这些数据，类似 NFS、HDFS ，然后将存储指针指向 ZooKeeper 的存储位置。 临时节点 ZooKeeper 当然也临时节点的概念。这些 Znodes 生命周期同 保持一致，当 session 创建的时候 Znodes 将被激活。当 session 结束 这个 Znode 也同时将被删除。正是由于这个行为临时节点不允许有子节点。 序列节点–唯一命名 在创建一个Znode的时候你也可以要求 ZooKeeper 在路径的后面追加一个递增的计数器。这个计数器相对于 Znode 是唯一的。这个计数器格式为 %010d – 这是一个10位数，用0占位（计数器用这个格式排序），“举例：000000000001”。点击Queue Recipe查看使用这个功能的例子。注意：用于存储下一个序列号的计数器是由父节点维护的带符号整型（4字节），计数器在增加到2147483647之后会溢出（导致名称为“ -2147483647”）。 ZooKeeper 时间 ZooKeeper 有很多方法去追踪这个时间 xid ZooKeeper 状态有任何修改都将会收到一个 zxid(ZooKeeper Transaction Id) 的标记。这个暴露了 ZooKeeper 所有的修改排序。每次修改都将会有一个唯一的 zxid，如果 zxid1 小于 zxid2 那么就可以认为 zxid1 是发生在 zxid2 之前。 Version numbers 所有对节点的修改都将造成这个节点的版本号增加。这三个版本数字就是version（znode数据修改的数量），cversion（znode子节点修改的数量），aversion（znode 修改的数量）。 Ticks 当使用多服务的 ZooKeeper，服务将使用 ticks 去定义事件时间，像（上传状态，会话超时，管道连接超时等等）。Tick 只会间接的暴露最小会话时间（两倍的 Tick time）；如果一个客户端的请求超时时间小于这个会话时间，服务器将告知客户端这个超时时间以最小的超时时间为准。 Real time ZooKeeper 不使用真实的时间或锁定时间，除了将时间戳放到 znode 的创建和修改的统计结构中。 ZooKeeper 统计结构 ZooKeeper 每个节点的统计结构由以下几个字段组成： czxid 表示造成这次 znode 创建的时间。 mzxid znode 最后的修改时间。 pzxid znode 子节点最后的修改时间。 ctime znode 创建时间（以毫秒为单位）。 mtime znode 最后的修改时间（以毫秒为单位）。 version znode 数据的修改次数。 cversion znode 子节点的修改次数 aversion znode 的修改次数 ephemeralOwner 如果是暂时节点，表示这个 znode 的主人的 session id 。如果不是，这个值为0. dataLength znode 数据字段的长度。 numChildren znode 有多少子节点 ZooKeeper 会话 ZooKeeper 客户端通过语言绑定于服务创建握手来建立与 ZooKeeper 服务的会话。一旦创建，句柄就会以CONNECTING状态开始，并且客户端库尝试连接到组成ZooKeeper服务的服务器之一，此时它将切换到CONNECTED状态。在正常的操作时候将会是这两者状态之一。如果发生一个不可逆转的错误事件，像 session 过期或者认证失败，再或者应用直接关闭了句柄，这个句柄将切换到 closed 状态。下面的图表展示了 ZooKeeper 客户端事物的处理状态： 要创建客户端会话，应用程序代码必须提供一个连接字符串，其中包含以逗号分隔的host：port对列表，每个对应于一个ZooKeeper服务器（举例：“127.0.0.1:4545” 或者 “127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002”）。ZooKeeper 客户端库将随机挑选一台服务器然后尝试去链接它。如果链接失败或者由于某些原因服务端到客户端断开链接，客户端都会自动尝试链接列表中的下一个服务，知道链接重新建立。 3.2.0 版本添加 可选后缀 “chroot” 可以追加到连接字符串后面。这会运行客户端命令以相对ROOT路径的形式（类似unix系统的chroot命令）。如果要举例的话看起来就像：“127.0.0.1:4545/app/a” 或 “127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a” 这样客户端就会以 “app/a” 为根目录，所有的路径都会相对于这个根目录。比如 “/foo/bar” 返回的结果将是运行 “/app/a/foo/bar” 得到（从服务器的角度来看）。这个功能在多租户环境真的很有用，每个 ZooKeeper 服务的用户可以有不同的根目录。这使得复用变得简单，用户可以将他的应用程序根目录编码成 “/” ，但是实际的位置可以在发布的时候在去决定。 当客户端获取到连接 ZooKeeper 服务的句柄，ZooKeeper 将创建一个以64位的数字表示的 ZooKeeper session，派送到客户端。如果客户端连接到一个不同的 ZooKeeper 服务，它将会发送一个 session id 作为连接握手的一个部分。为了保证安全，服务端会给 session id 创建一个秘密，任何的 ZooKeeper 服务都可以去验证。这个密码将会在客户端建立会话的时候和 session id 一起发送到客户端。客户端随时都可以发送这个密码和 session id 跟一个新的服务重新建立会话。 ZooKeeper 客户端库用来创建 ZooKeeper session超时的参数是用毫秒表示。客户端发送一个超时请求，服务端将响应一个超时给到客户端。现在的实例要求超时至少是两倍 tickTime （这个可以在服务端配置）或者大于20倍的tickTime。ZooKeeper 客户端API允许访问协商超时时间。 如果客户端是 ZooKeeper 服务集群中的分区，它将会开始搜索在 session 创建期间指定的服务器列表。实际上，当客户端和最后一个服务器之间重新建立起连接， session 将会切换到 “connected” 状态（如果重连在超时时间范围内）或者切换到 “expired” 状态（如果重连时间已经超出超时时间）。为断开链接创建一个新的 session 对象这是一个不明智的决定（一个新的 ZooKeeper类 或 zookeeper 对象在 C 绑定中处理 ）。ZooKeeper 客户端库将会帮你自动重新连接。特别是，我们在客户端库中内置了启发式技术，以处理诸如“群效应”等等… 当你被通知到 session 过期（强制性）的时候，只能创建一个新的 session。 session 过期通过 ZooKeeper 集群自己管理，不是通过客户端。当 ZooKeeper 客户端建立一个集群 session 它将提供一个详细的 timeout 值。这个值是集群用来确定客户端的 session 何时过期。当集群没有收到来自客户端指定的过期时间（比如：没有心跳）将会直接过期。在 session 过期时集群将会删除任何/所有这个 session 所拥有的临时节点并且立刻通知所有连接的客户端这个事情（任何监控这些节点的客户端）。在这个时候会话过期的时间点于集群是一直保持断开状态，session 过期不会被通知到直到它可以重新连接到集群。客户端将会一直保持断开状态一直到重新 TCP 连接到集群，在这个时间点上如果 session 过期，监控者将收到 session 过期的通过。 举一个会话过期监控者看到的会话过期状态转换的例子： ‘connected’ : session is established and client is communicating with cluster (client/server communication is operating properly) … client is partitioned from the cluster ‘disconnected’ : client has lost connectivity with the cluster … time elapses, after ‘timeout’ period the cluster expires the session, nothing is seen by client as it is disconnected from cluster … time elapses, the client regains network level connectivity with the cluster ‘expired’ : eventually the client reconnects to the cluster, it is then notified of the expiration ZooKeeper 调用会话建立的另外一个参数是默认的 watchers。当客户端任何一个改变状态的事件发生 watchers 都是收到通知。举个例子：如果客户端丢失了跟服务器端的连接客户端将收到通知，或者如果客户端的 session 过期等等… 这个 watcher 应该考虑到初始化状态为断开状态。（比如：在客户端库把状态变化的事件发送到 watcher 之前）。在新的连接案例中，第一个发送到 watcher 的事件一般是 session 连接事件。 ZooKeeper 通过客户端发送请求保持 session 不过期。如果让 session 保持一段时间的空闲将使得 session 过期，所以客户端会一直发送一个 ping 请求保证 session 一直存活。这个 ping 请求不仅仅只是让 ZooKeeper 服务知道这个客户端还活着，还可以让客户端验证它连接的 ZooKeeper 服务是否一直活着。这个 ping 请求的时间安排的足够合理保证有充足的时间去检测断开的连接和重新去连接一个新的服务。 一旦一个到服务器端的连接成功被建立，基本上有两种情况客户端库生成一个 connectionloss（这个返回码会在 C binding 中， java 的话会在异常里面 – 看 API 文档会有详细的介绍）如果有同步或者异步的操作被执行而且有以下情况之一： 应用程序在一个 session 过期或者无效的服务器上执行一项操作。 在客户端在等待服务响应的时候，服务断开连接，比如：在等待异步调用的响应的时候。 3.2.0 版本添加 – SessionMovedException. 这是一个内部的异常，通常不会被客户端看到。 Added in 3.2.0 – SessionMovedException. There is an internal exception that is generally not seen by clients called the SessionMovedException. This exception occurs because a request was received on a connection for a session which has been reestablished on a different server. The normal cause of this error is a client that sends a request to a server, but the network packet gets delayed, so the client times out and connects to a new server. When the delayed packet arrives at the first server, the old server detects that the session has moved, and closes the client connection. Clients normally do not see this error since they do not read from those old connections. (Old connections are usually closed.) One situation in which this condition can be seen is when two clients try to reestablish the same connection using a saved session id and password. One of the clients will reestablish the connection and the second client will be disconnected (causing the pair to attempt to re-establish its connection/session indefinitely). ZooKeeper 监控 监控语义 如何保障 ZooKeeper 订阅者 关于订阅者的事项 ZooKeeper 权限控制 (ACL) ACL权限 ACL内建方案 ZooKeeper C 客户端 API 插件式的 ZooKeeper 认证 一致性保证 绑定 Java 绑定 C 绑定 安装 构建属于你的 C 客户端 构建模块：ZooKeeper 操作指南 解决错误 连接 ZooKeeper 读取操作 写入操作 处理订阅者 混杂 ZooKeeper 操作 程序结构（简单案例） 陷阱：常见问题和故障排除","categories":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://fantasylion.github.io/categories/zookeeper/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://fantasylion.github.io/tags/zookeeper/"}]},{"title":"Ebbinghaus Forgetting Curve","slug":"2018-01-31-The-Shawshank-Redemption","date":"2018-01-30T16:00:00.000Z","updated":"2018-01-30T16:00:00.000Z","comments":true,"path":"English/2018-01-31-The-Shawshank-Redemption/","link":"","permalink":"https://fantasylion.github.io/English/2018-01-31-The-Shawshank-Redemption/","excerpt":"The Shawshank Redemption","text":"The Shawshank Redemption 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199Mr.Dufresne, describe the confrontation you had with your wife the night she wwas murdered.It was very bitter.She said she was glad I knew that she hated all the sneaking around. And she said that she wanted a divorce in Reno.What was your reponse?I told her I would not grant one.I&#39;ll see you in hell before I see you in Reno. Those were your words, according to your neighbors.If they say so. I really don&#39;t remember. I was upset.What Happened after you argued with your wife?She packed a bag. She packed a bag to go and stay with Mr.Quentin.Glenn Quentin, golf pro at the Snowden Hills Country Club whom you had discovered was your wife&#39;s lover. Did you followher?I went to a few bars first. Later, I drove to his house to confront them. They weren&#39;t home. So I parked in the turnout and waited.[Some errors here]With what intention?I&#39;m not sure. I was confused, drunk, I think mostly I wanted to scare them.When they arrived, you went up to the house and murdered them.No, I was sobering up.I got back in the car and I drove home to sleep it off.Along the way, I threw my gun into the Royal River. I&#39;ve been very clear on this point.Well I get hazy where the cleaning woman shows up the following morning, and finds your wife in bed with her lover riddledwith 38-caliber bullets. Does that strike you as a fantastic coincidence, or is it just me?Yes it dose.Yet you still maintain you threw your gun into the river before the murders took place. That&#39;s very convenient.It&#39;s the truth.The police dragged that river for three days, and nary a gun was found, so no comparison could be made between yourgun and the bullets taken from the bloodstained corpses of the victims. And that also is very convenient.Isn&#39;s it, Mr,Dufresne?Since I am innocent of this crime.I find it decidedly inconvenient that the gun was nerver found.Ladied and gentlemen, you&#39;ve heard all the evidence.[Lost some words] We have the accused at the scene of the crime.We have footprints. Bullets on the ground bearing his fingerprints. A broken bourbon bottle, likewise with fingerprints.And most of all, We have a beautifull young woman and her lover lying dead in each other&#39;s arms. They had sinned.But was their crime so great as to merit a death sentence? While you think about that,think about this: A revoiver holds six bullets, not eight. I submit that this was not a hot-blooded crime of passion.That at least could be understood, if not condoned. NO! This was revenge of a much more brutal, cold-blooded nature, Consider this: Four bullets per victim Not six shots fired, but eight. That means that he fired the gun emptyand then stopped to reload so that he could shoot each of them again. And extra bullet per lover right in the head.You strike me as a particularly icy and remoreseless man, Mr.Dufresne. It chills my blood just to look at you.By the power vested in me by the state of Maine. I hereby order you to sever two life sentences back-to-backon for each of your victims. So be it!Sit.We see you&#39;ve served 20 year of a life sentence?Yes, sir.Your feel you&#39;ve been rehabilitated?Yes sir. Absolutely, sir. I mean, I learned my lessson. I can honestly say that I&#39;m a changed man. I&#39;m no longer a danger to society. That&#39;s God&#39;s honest truth.Hey red, How&#39;d it go?Same old shit, different day.Yeah, I know how you feel.I&#39;m up for rejection next week.Yeah, I got rejected last week.It happens.Hey, Red, bump me a deck.Get out of my face, man! You&#39;re into me for five packs already.Four!-Five!There must be a con like me in every prison in America. I&#39;m the guy who can get it for you. Cigarettes, a bag of reefer,if that&#39;s your thing... A bottle of brandy to celebrate your kids high school graduation. Damn near anything within reason.Yes sir. I&#39;m a regular sears an Roebuck.So when Andy Dufresne came to me in 1949 and asked me to smuggle Rita Hayworthinto the prison for him. I told him, &quot;No problem&quot;Officers to main gate. Officers to main gate. Secure main gate.Andy came to Shawshank Prison in early 1947 for murdering his wife and the fella she was banging.On the outside, he&#39;d been vice president of a large Portland bank.Good work for a man so young.[Lost some words]Hey Red.You speak English, butt-steak? You follow this officer.I never seen such a sorry-looking heap of maggot shit in all my life.Hey, fish! Come over here!Taking bets today, Red?Smokers or coin? Bettor&#39;s choice.Smokes. Put me down for tow.All right, who&#39;s your horse?That little sack of shit.Eighth.He&#39;ll be first.-Bullshit! I&#39;ll take that action.You&#39;re out some smokes, son.If your&#39;re so smart, you call it.I&#39;ll take the chubby fat-ass three.The fifth one. Put me down for a quarter deck.Fresh fish today! We&#39;re reeling them in!I must admit I didn&#39;t think much of Andy first time I laid eyes on him. Looked like a stiff breeze would blow him over.That was my first impression of the man.What do you say?That tall drink of water the silver spoon up his ass.That guy?Never happen.Ten cigarettes-That&#39;s a rich bet. Who&#39;s going to prove me wrong? Heywood?Jigger?Skeets?Floyd!Four brave souls.Return to your cellblocks for evening count.All prisoners, return to your cellblocks.Turn o the right! Eyes front.This is Mr.Hadley. He&#39;s captain of the guards.I&#39;m Mr.Norton, the warden. You are conviceted felons.That&#39;s why they&#39;ve sent you to me.Rule number one: No blasphemy, I&#39;ll not have the lord&#39;s name taken in vain in my prison. The other rules, you&#39;ll figure out as you goalong. Any questions?When do we eat?You eat when we say you eat. You shit when we say you shit, and piss when we say you piss. You got that, you maggot-dick motherfucker?On your feet.I believe in two things: Discipline and the Bible. Here, you&#39;ll receive both. Put your trust in the Lord. Your ass belongs to me.Welcome to Shawshank.Unhook them.[time is 14:19]Turn around.That&#39;s enough. Move to the end of the cage. Turn around. Delouse him. Turn around. Move out of the cage.Pick up your clohes and Bible. Next man up. To the right. Right. Right. Left. The first night&#39;s the toughest. No doubt about it.They march you in naked as the day you were born. Skin burning and half-blind from that delouing shit. And when they put you in that cell and those bars slam home. That&#39;s when you know it&#39;s for real. Old life blown away in the blink of an eye. Nothing leftbut all the time in the world to think about it. Most new fish come close to madness the first night. Somebody always breaks down crying. Hapens every time. The only question is who&#39;s it going to be? It&#39;s as good a thing to bet on as any, I guess. I had mymoney on Andy Dufresne.Lights out.I remember my first night.Seems like a long time ago.Hey fish, fish ,fish, what are you, scared of the dark? Bet you wish your daddy never dicked your mama? Piggy! Pork! I want mea port chop.Poke your ass out, give me a first look! Keep it down.The boys always go fishing with first-timers. And the don&#39;t quit till they reel someone in.Hey, Fat Ass. Take to me boy. I know your&#39;re there. I can hear you breathing. Don&#39;t you listen to these nitwits, you hear me?This place ain&#39;t so bad. Tell you what, I&#39;ll introduce you around, make you feel right at home.I konw a couple of big od bull queers that&#39;d just love to make your acquaintance. Especially that big,white, mushy butt of yours.Glod!I don&#39;t belong here!We have a winner!- I want to go home!And it&#39;s Fat Ass by a nose!Fresh fish! Fresh fish! Fresh fish!I don&#39;t belong here. I want to go home. I want my mother!I had your mother! She wasn&#39;t that great![time is 18:01]","categories":[{"name":"English","slug":"English","permalink":"https://fantasylion.github.io/categories/English/"}],"tags":[{"name":"English","slug":"English","permalink":"https://fantasylion.github.io/tags/English/"}]},{"title":"Ebbinghaus Forgetting Curve","slug":"2018-01-02-How-to-remember-sthing","date":"2018-01-01T16:00:00.000Z","updated":"2018-01-01T16:00:00.000Z","comments":true,"path":"English/2018-01-02-How-to-remember-sthing/","link":"","permalink":"https://fantasylion.github.io/English/2018-01-02-How-to-remember-sthing/","excerpt":"利用艾宾浩斯遗忘曲线背单词","text":"如何运用艾宾浩斯遗忘曲线背单词 复习点的确定 1． 第一个记忆周期：5分钟 2． 第二个记忆周期：30分钟 3． 第三个记忆周期：12小时 4． 第四个记忆周期：1天 5． 第五个记忆周期：2天 6． 第六个记忆周期：4天 7． 第七个记忆周期：7天 8． 第八个记忆周期：15天 背诵方法 1． 初记单词时需要记忆的内容： 123a）单词外观b） 单词的中文释义c） 单词的记忆法 2． 每个list的具体背诵过程（每个list按12页，每页10个单词计）： 12345a) 背完一页（大约5分钟），立即返回该页第一个单词开始复习（大约几十秒）b) 按上面方法背完1～6页（大约在30分钟），回到第1页开始复习（两三分钟）c) 按上面同样方法背完7～12页，一个list结束d) 相当于每个list被分为12个小的单元，每个小的单元自成一个复习系统； 每6个小单元组成一个大单元，2个大单元各自成为一个复习系统。背一个list总共需要一小时左右的时间。 复习过程 a) 复习方法：遮住中文释义，尽力回忆该单词的意思，几遍下来都记不住的单词可以做记号重点记忆。 b) 复习一个list所需的时间为20分钟以内 c) 当天的list最好在中午之前背完，大约12小时之后（最好睡觉前）复习当天所背的list d) 在其后的1，2，4，7，15天后分别复习当日所背的list e）复习的原则 时间间隔：30秒 1分钟 5分钟 30分钟 1小时 8小时 1天 2天 6天 31天 重学节省诵读时间百分数：58.2 44.2 35.8 33.7 27.8 25.4 21.1 复习点的确定 123456789101112131415人的记忆周期分为短期记忆和长期记忆两种。第一个记忆周期是 5分钟第二个记忆周期是30分钟第三个记忆周期是12小时这三个记忆周期属于短期记忆的范畴。下面是几个比较重要的周期。第四个记忆周期是 1天第五个记忆周期是 2天第六个记忆周期是 4天第七个记忆周期是 7天第八个记忆周期是15天以上的8个周期应用于背词法，作为一个大的背词的循环的8个复习点，可以最大程度的提高背单词的效率背单词就找个小本子窄窄的那种，每页中间对折左边英文右边中文，每天背100个，分5组每组20个，每一个看过留下读音和拼写的印象，基本上5～8分钟一组，全部5组大概看30分钟，最好不要超过40分钟，然后再从第一组再看，每天一百个新的，看过的按记忆周期在第2、4、7、15天重新复习，基本每天进行的300～400个单词记忆。 英语背诵任务 a) 每天连续背诵1个list，每个list 120个单词，并完成复习任务； b) 复习永远比记新词重要，要反复高频率的复习，复习，再复习； c) 一天都不能间断，坚持挺过这15天，之后每天都要花大约1小时复习； 时间表 123456789101112131415161718192021222324252627282930313233343536373839 新学 背诵第1天： list1 *list1第2天： list2 *list1 *list2第3天： list3 *list2 *list3第4天： list4 *list3 *list1 *list4第5天： list5 *list4 *list2 *list5第6天： list6 *list5 *list3 *list6第7天： list7 *list6 *list4 *list1 *list7第8天： list8 *list7 *list5 *list2 *list8第9天： list9 *list8 *list6 *list3 *list9第10天： list10 *list9 *list7 *list4 *list10第11天： list11 *list10 *list8 *list5 *list11第12天： list12 *list11 *list9 *list6 *list12第13天： list13 *list12 *list10 *list7 *list13第14天*： list14 *list13 *list11 *list8 *list14第15天： list15 *list14 *list12 *list9 *list1 *list15第16天： list16 *list15 *list13 *list10 *list2 *list16第17天： list17 *list16 *list14 *list11 *list3 *list17第18天： list18 *list17 *list15 *list12 *list4 *list18第19天： list19 *list18 *list16 *list13 *list5 *list19第20天： list20 *list19 *list17 *list14 *list6 *list20第21天： list21 *list20 *list18 *list15 *list7 *list21第22天： list22 *list21 *list19 *list16 *list8 *list22第23天： list23 *list22 *list20 *list17 *list9 *list23第24天： list24 *list23 *list21 *list18 *list10 *list24第25天： list25 *list24 *list22 *list19 *list11 *list25第26天： list26 *list25 *list23 *list20 *list12 *list26第27天： list27 *list26 *list24 *list21 *list13 *list27第28天： list28 *list27 *list25 *list22 *list14 *list28第29天： list29 *list28 *list26 *list23 *list15 *list29第30天： list30 *list29 *list27 *list24 *list16 *list30第31天： list31 *list30 *list28 *list25 *list17 *list31第32天： list32 *list31 *list29 *list26 *list18 *list32第33天： list33 *list32 *list30 *list27 *list19 *list33第34天： list34 *list33 *list31 *list28 *list20 *list34第35天： list35 *list34 *list32 *list29 *list21 *list35第36天： list36 *list35 *list33 *list30 *list22 *list36第37天： list37 *list36 *list34 *list31 *list23 *list37第38天： list38 *list37 *list35 *list32 *list24 *list38 注意事项 a) 每天连续背诵2个list，并完成复习任务； b) 复习永远比记新词重要，要反复高频率的复习，复习，再复习； c) 一天都不能间断，坚持挺过这15天，之后每天都要花大约1小时复习； 时间表（左边序号表示第几天，*号之后表示复习内容） 123456789101112131415161718192021222324252627282930313233343536373839404142 第1天 list1→2 *list1→2 第2天 *list1→2 list3→4 *list3→4 第3天 *list3→4 list5→6 *list5→6 @ 第4天 *list1→2 *list5→6 list7→8 *list7→8 第5天 *list3→4 *list7→8 list9→10 *list9→10 第6天 *list5→6 *list9→10 list11→12 *list11→12 第7天 *list1→2 *list7→8 *list11→12 list13→14 *list13→14 第8天 *list3→4 *list9→10 *list13→14 list15→16 *list15→16 第9天 *list5→6 *list11→12 *list15→16 list17→18 *list17→18 第10天 *list7→8 *list13→14 *list17→18 list19→20 *list19→20 第11天 *list9→10 *list15→16 *list19→20 list21→22 *list21→22 第12天 *list11→12 *list17→18 *list21→22 list23→24 *list23→24 第13天 *list13→14 *list19→20 *list23→24 第14天 *list15→16 *list21→22 第15天 *list1→2 *list17→18 *list23→24 第16天 *list3→4 *list19→20 第17天 *list5→6 *list21→22 第18天 *list7→8 *list23→24 第19天 *list9→10 第24天 *list19→20 第25天 *list21→22 第26天 *list23→24 第27天 第28天 第29天 第30天 *list1→2 第31天 *list3→4 第32天 *list5→6 第33天 *list7→8 第34天 *list9→10 第35天 *list11→12 第36天 *list13→14 第37天 *list15→16 第38天 *list17→18 第39天 *list19→20 第40天 *list21→22 第41天 *list23→24 起始(单元或页码)编号为1 截止(单元或页码)编号为24 总共需要复习的编号数为24 每天需要复习的编号数为2 你需要41天时间完成任务[4]","categories":[{"name":"English","slug":"English","permalink":"https://fantasylion.github.io/categories/English/"}],"tags":[{"name":"English","slug":"English","permalink":"https://fantasylion.github.io/tags/English/"}]},{"title":"Enterprise Architect key","slug":"2016-05-06-Enterprise-Architect-key","date":"2016-05-05T16:00:00.000Z","updated":"2016-05-05T16:00:00.000Z","comments":true,"path":"Tools/2016-05-06-Enterprise-Architect-key/","link":"","permalink":"https://fantasylion.github.io/Tools/2016-05-06-Enterprise-Architect-key/","excerpt":"Enterprise Architect是一款非常好用的建模软件","text":"前言 Enterprise Architect是一款非常好用的建模软件 Enterprise Architect11企业版注册码 1234Registration KeyADF8D83B-0683-4d1f-BB60-FF66D-WFM1-CHPZ-PII0-HN75-BCAuthorization KeyF08113BA-8B4F-41df-8F01-46DF2C35D249","categories":[{"name":"Tools","slug":"Tools","permalink":"https://fantasylion.github.io/categories/Tools/"}],"tags":[{"name":"uml","slug":"uml","permalink":"https://fantasylion.github.io/tags/uml/"}]},{"title":"spring boot使用","slug":"2016-04-27-spring-boot","date":"2016-04-26T16:00:00.000Z","updated":"2016-04-26T16:00:00.000Z","comments":true,"path":"program/2016-04-27-spring-boot/","link":"","permalink":"https://fantasylion.github.io/program/2016-04-27-spring-boot/","excerpt":"spring团队为了方便使用spring，开发出了springBoot将spring的配置都简单化了","text":"前言 spring团队为了方便使用spring，开发出了springBoot将spring的配置都简单化了。SpringBoot也是在微服务架构中使用比较频繁的一个框架。 介绍 SpringBoot把创建一个独立的网站变得更加的简单。启动一个SpringBoot的应用你只需要简单的run一下就可以。基本上SpringBoot的应用只需要很少的配置就可以。 你可以使用SpringBoot去创建一个java应用，可以通过命令java -jar或者启动’war’包，而且他们提供了’spring scripts’可以更方便的启动应用。 SpringBoot 目标 为所有Spring开发一种完全更快普及入门体验。 自以为是开箱即用，但得到的出路尽快开始要求从默认发散。 提供一系列的非功能性特征是常见的大课的项目（例如嵌入式服务器，安全，指标，健康检查，外部配置）。 绝对没有生成代码,没有要求配置XML。 系统要求 默认使用SpringBoot 1.3.5.release Java 7 Spring Frameework 4.2.6RELEASE 以上 当然SpringBoot内嵌了许多应用服务器 Name Servlet version Java Version Tomcat8 3.1 Java 7+ Tomcat7 3.0 Java 6+ jetty9 3.1 Java 7+ jetty8 3.0 Java 6+ Undertow1.1 3.0 Java 6+","categories":[{"name":"program","slug":"program","permalink":"https://fantasylion.github.io/categories/program/"}],"tags":[{"name":"java","slug":"java","permalink":"https://fantasylion.github.io/tags/java/"}]},{"title":"心甘情愿","slug":"2016-04-01-love","date":"2016-03-31T16:00:00.000Z","updated":"2016-03-31T16:00:00.000Z","comments":true,"path":"LifeFeeling/2016-04-01-love/","link":"","permalink":"https://fantasylion.github.io/LifeFeeling/2016-04-01-love/","excerpt":"世界上最幸福的事，莫过于想起一个人的时候！","text":"《心甘情愿》 世界上最幸福的事，莫过于想起一个人的时候！ 脸上露出的笑意，心中流动的暖意。 不由自主的想起，是心中柔软的秘密； 情不自禁的挂念，是生命不可或缺的一部分。 相见或者不见，心一直在陪伴； 知冷知热的情，让心灵有了靠岸； 含笑带泪的暖，给生命以春天。 思念不为容颜，只为感觉； 眷恋不为拥有，只为懂得。 相识于路上，不如相知于心上！ 人在难受的时候，特别需要的是最爱的人来陪。 哪怕是一杯平淡的白水，也会暖心暖肺； 即使是一句简单的安慰，也能深入心扉。 卸下了伪装，不在狼狈； 除去了疲惫，不在憔悴。 也许那个人并不完美，但在你眼里就是最美； 也许那颗心会偶尔忽略，但却是你最想要的体会。 人海再多，这种感觉别人不能给就； 缘分无数，这份感情无人能媲美。 一个人的心最不会说谎，心在哪里，爱就在哪里！","categories":[{"name":"LifeFeeling","slug":"LifeFeeling","permalink":"https://fantasylion.github.io/categories/LifeFeeling/"}],"tags":[{"name":"爱","slug":"爱","permalink":"https://fantasylion.github.io/tags/%E7%88%B1/"}]},{"title":"FFmpeg使用","slug":"2016-03-30-introduce-ffmpeg","date":"2016-03-29T16:00:00.000Z","updated":"2016-03-29T16:00:00.000Z","comments":true,"path":"tools/2016-03-30-introduce-ffmpeg/","link":"","permalink":"https://fantasylion.github.io/tools/2016-03-30-introduce-ffmpeg/","excerpt":"FFmpeg introduction","text":"介绍FFmpeg FFmpeg的是全球领先的多媒体框架，能够解码，编码，转码，复用，解复用，流，过滤器和播放。它支持各种格式的视频。","categories":[{"name":"tools","slug":"tools","permalink":"https://fantasylion.github.io/categories/tools/"}],"tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://fantasylion.github.io/tags/ffmpeg/"}]},{"title":"排序算法总计(未完结)","slug":"2016-02-27-data-structure-for-sort","date":"2016-02-26T16:00:00.000Z","updated":"2016-02-26T16:00:00.000Z","comments":true,"path":"notes/2016-02-27-data-structure-for-sort/","link":"","permalink":"https://fantasylion.github.io/notes/2016-02-27-data-structure-for-sort/","excerpt":"北京的生活已经远去，新的生活即将开始，趁现在有空将学校学过的计算机基础知识复习一下，先看一下排序算法","text":"北京的生活已经远去，新的生活即将开始，趁现在有空将学校学过的计算机基础知识复习一下，先看一下排序算法 排序篇 基本概念 排序是计算机程序设计中的一种重要操作。不论数值计算还是非数值计算问题都要广泛地用到排序运算，特别是在数据处理方面引用的更加广泛。它的功能是将一个数据元素的任意序列，重新排列成一个按指定官架子有序的序列。排序的目的是便于查找，提高计算机的工作效率。因此，学习和研究各种排序方法是计算机工作中的重要课题之一。 插入排序 基本思想：每次将一个待排序的记录，按其关键字的大小插入到前面已经排好序的有序序列中的适当位置上，直到全部记录插入完成为止。按照插入的方法不通可以分为好几种，其中：直接插入排序，折半插入排序，2-路插入排序和希尔排序。 直接插入排序 基本思想 将序列中的元素依次的插入到有序序列中，导致最终结果有序序列不断变长，直到取完最后一个无序序列中的元素 折半插入排序 利用折半查找来实现插入位置的定位，因为折半查找的效率比较高，因此可以减少排序过程中的比较次数。适用于待排序的记录数量较大的情况。 2-路插入排序 希尔排序 希尔排序方法又称为缩小增量排序，它也是一种插入排序方法，是对直接插入排序方法的改进。 基本思想 将整个待排序的记录序列划分成若干个子序列，然后分别对每个子序列进行直接插入排序，这样可以减少参与直接插入排序的数据量，如此反复，当经过几次分组排序后，记录的排序依据基本有序，这个时候在对所有的记录进行一次直接插入排序。 例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样： 123456713 14 94 33 8225 59 94 65 2345 27 73 25 3910 然后我们对每列进行排序： 123456710 14 73 25 2313 27 94 33 3925 59 94 65 8245 將上述四行數字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序： 123456789101110 14 7325 23 1327 94 3339 25 5994 65 8245 排序之后变为： 123456789101110 14 1325 23 3327 25 5939 65 7345 94 8294 最后以1步长进行排序（此时就是简单的插入排序了）。 选择排序 选择排序思想 每一趟从待排序的序列中选出关键字最小的记录，按顺序放在已排好序的子序列的最后，直到全部记录排序完毕。常用的选择排序方法有简单选择排序和堆排序。 简单选择排序 堆排序 交换排序 交换排序的基本思想是：两两比较待排序记录的关键字，若发现两个记录的次序为逆序时，交换其存储位置，直到没有逆序的记录位置。下面介绍两个比较常用的交换排序：冒泡排序和快速排序。 冒泡排序 冒泡排序的基本思想： 对所有相邻记录的关键字值进行比较，如果是逆序(r[i]&gt;[i+1]),则交换其位置，进过多趟排序，最终使整个序列有序。 就是不断的将一个元素向后移动，直到移动到这个值最后所因在的位置。这个过程有点像水中冒泡一样不断的向上扩大直到水泡变得它所能承受的最大体积然后爆裂。 快速排序 排序排序基本思想： 快排是对冒泡排序的一种改进，它通过一趟排序将待排序记录划分成两部分，是的其中一部分记录的关键字比另一部分记录的关键字小；然后再分别对这两部分记录进行这种划分，直到每个部分为空或只包含一个记录时，整个快速排序结束。 归并排序 归并排序是将两个或者两个以上的有序序列合成一个新的有序序列。 基数排序 多关键字排序 链式基数排序 排序的几种方法","categories":[{"name":"notes","slug":"notes","permalink":"https://fantasylion.github.io/categories/notes/"}],"tags":[{"name":"DS","slug":"DS","permalink":"https://fantasylion.github.io/tags/DS/"}]},{"title":"MongoDB笔记2-使用MongoDB","slug":"2016-02-20-use-mongodb-2","date":"2016-02-19T16:00:00.000Z","updated":"2016-02-19T16:00:00.000Z","comments":true,"path":"database/2016-02-20-use-mongodb-2/","link":"","permalink":"https://fantasylion.github.io/database/2016-02-20-use-mongodb-2/","excerpt":"如何使用MongoDB去存储数据，对数据进行增删改查等操作。","text":"使用MongoDB MongoDB存储和操作的数据是以类似JSON的格式数据，使用MongoDB的命令有点类似在页面console中写js的感觉。 创建一个数据库 使用如下命令进行数据库创建 12&gt; use mongotestDBswitched to db mongotestDB use：切换到某个数据库，如果这个数据库不存在则会创建一个数据库对象。这个时候使用show dbs是查询不到这个数据库的，只有在insert一条数据后才能查到。从这里可以看出show dbs命令是从磁盘上去查询的 插入数据 使用以下命令及可插入一条数据 12&gt; db.mycollection.insert(&#123;x:10&#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;) db 代表你当前使用的数据库 mycollection 代表你的数据要插入到哪个集合，如果这个集合不存在或者说没有使用过则会创建一个新的集合并将数据插入到这个集合中。 如果你的集合名需要空格或者一些符号，但是使用的Mongo shell又不支持的话可以使用以下方式 1234&gt; db[&quot;collection-test&quot;].insert(&#123;x:20&#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.getCollection(&quot;collection-test&quot;).insert(&#123;x:20&#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;) 当然如果觉得数据写的太长也可以这么插入 123&gt; var doc &#x3D; &#123;xx:1,ary:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]&#125;&gt; db.mycollection.insert(doc)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;) 批量插入 123456789101112&gt; var doc &#x3D; [&#123;x:1&#125;,&#123;x:2&#125;,&#123;x:3&#125;,&#123;x:4&#125;]&gt; db.mycollection.insert(doc)WriteResult(&#123; &quot;writeErrors&quot; : [], &quot;writeConernErroes&quot;:[], &quot;nInserted&quot; : 4, &quot;nUpserted&quot; : 0, &quot;nMatched&quot;:0, &quot;nModified&quot;:0, &quot;nRemoved&quot;:0, &quot;upserted&quot;:[]&#125;) 如果需要批量的插入，首先声明一个数组，这个数组里存放需要插入的数据。如上面所示插入4条数据 查询数据 MongoDB使用find函数（我不知道应该说命令还是函数-_-|||）去查询，还有一个是findOne函数。 查询mycollection中所有的数据 12&gt; db.mycollection.find(&#123;&#125;)&#123;&quot;_id&quot;:Object(56c870d24d49c30492efa870), &quot;x&quot;:1&#125; 条件查询 12&gt; db.mycollection.find(&#123;x:&#123;$gt:0&#125;&#125;)&gt; db.mycollection.find(&#123;x:&#123;$lt:0&#125;&#125;) 大于(greater than)使用$gt，上面命令第一条命令表示：查询x大于0的所有数据 小于(less than)使用$lt，第二条表示：查询x小于0的所有数据 查询显示指定字段 1&gt; db.mycollection.find(&#123;x:&#123;$gt:0&#125;&#125;, &#123;x:1&#125;) 查询x大于0的所有数据，只列出x字段 1&gt; db.mycollection.find(&#123;x:&#123;$gt:0&#125;&#125;, &#123;x:0&#125;) 查询x大于0的所有数据，不显示x字段 某个条件内查询 1&gt; db.testCollection.find(&#123;x:&#123;$in:[10,11]&#125;&#125;) 查询testCollection中x在属于10或11中的所有数据 条件或查询 1&gt; db.testCollection.find(&#123;$or:[&#123;x:&#123;$gt:12&#125;&#125;,&#123;t:3&#125;]&#125;) 查询testCollection中x大于12或者t小于3的所有数据 查询嵌入文档 先插入一个文档doc 123456&gt; db.testCollection.insert(&#123;doc:&#123;y:1,t:2,c:3&#125;&#125;)&gt; db.testCollection.insert(&#123;doc:&#123;y:2,t:3,c:4&#125;&#125;)&gt; db.testCollection.insert(&#123;doc:&#123;y:3,t:4,c:5&#125;&#125;)&gt; db.testCollection.insert(&#123;doc:&#123;y:4,t:5,c:6&#125;&#125;)&gt; db.testCollection.insert(&#123;doc:&#123;y:5,t:6,c:7&#125;&#125;)&gt; db.testCollection.insert(&#123;doc:&#123;y:6,t:7,c:8&#125;&#125;) 查询doc={y:1,t:2,c:3} 1&gt; db.testCollection.find(&#123;doc:&#123;y:6,t:7,c:8&#125;&#125;) 查询所有doc中y = 6的数据 1&gt; db.testCollection.find(&#123;&quot;doc.y&quot;:6&#125;&#125;) 查询所有doc中y &gt; 3的数据 1&gt; db.testCollection.find(&#123;&quot;doc.y&quot;:&#123;$gt:3&#125;&#125;) 查询数组 先插入一些数组 12345&gt; db.testCollection.insert(&#123;ary:[1,2,3,4,5,6,7]&#125;)&gt; db.testCollection.insert(&#123;ary:[3,5,6,7,5,6,3]&#125;)&gt; db.testCollection.insert(&#123;ary:[5,5,1,7,5,4,3]&#125;)&gt; db.testCollection.insert(&#123;ary:[4,5,6,6,7,6,3]&#125;)&gt; db.testCollection.insert(&#123;ary:[2,5,4,7,5,7,3]&#125;) 查询ary=[1,2,3,4,5,6,7]的所有数据 1&gt; db.testCollection.find(&#123;ary:[1,2,3,4,5,6,7]&#125;) 查询数据第0个数等于2的数据 1&gt; db.testCollection.find(&#123;&quot;ary.0&quot;:2&#125;) 查询数组中某个元素满足条件 1&gt; db.testCollection.find(&#123;ary:&#123;$elemMatch:&#123;$gt:2, $lt:5&#125;&#125;&#125;) 查询条件ary中存在元素满足大于2小于5的所有数组 MongoDB支持查询优化，详情点击&gt;&gt;&gt; 修改数据 MongoDB提供update函数，$set操作符来执行更新操作 1&gt; db.testCollection.update(&#123;x:1&#125;,&#123;$set:&#123;x:100&#125;, $currentDate: &#123; lastModified: true &#125;&#125;) 将满足x为1的数据x值改为100，并通过$currentDate添加时间字段lastModified 默认情况下使用update函数只更新一条数据，如果需要更新多条数据使用操作字段multi 1&gt; db.testCollection.update(&#123;x:1&#125;,&#123;$set:&#123;x:100&#125;, $currentDate: &#123; lastModified: true &#125;&#125;, &#123; multi: true &#125;) 直接替换 1&gt; db.testCollection.update(&#123;x:1&#125;,&#123;x:111, y:100 &#125;) 满足x=1条件的第一条数据将会被替换成{x:111, y:100} 如果加上upsert字段并设值为true将会修改多条满足条件的数据，如果不存在此条件的数据将会添加一条数据 删除数据 MongoDB使用remove函数进行删除操作 删除集合中所有的数据 1&gt; db.testCollection.remove(&#123;&#125;) 删除满足条件的数据 1&gt; db.testCollection.remove(&#123;x:1&#125;) 删除单个数据，设置参数1或者true 1&gt; db.testCollection.remove(&#123;x:1&#125;, 1)","categories":[{"name":"database","slug":"database","permalink":"https://fantasylion.github.io/categories/database/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://fantasylion.github.io/tags/MongoDB/"}]},{"title":"人生有感","slug":"2016-02-19-my-grandma","date":"2016-02-18T16:00:00.000Z","updated":"2016-02-18T16:00:00.000Z","comments":true,"path":"LifeFeeling/2016-02-19-my-grandma/","link":"","permalink":"https://fantasylion.github.io/LifeFeeling/2016-02-19-my-grandma/","excerpt":"人生就像一场旅行，在乎的不是目的地而是沿途的风景","text":"《青春》 所有的结局都已写好 所有的泪水也都已启程 切忽然忘了是怎样的一个开始 在哪个古老的不再回来的夏日 无论我如何地去追索 年轻的你只如云影掠过 而你微笑的面容极浅极浅 逐渐隐没在日落后的群岚 遂翻开那发黄的扉页 命运将它装订的极为拙劣 含着泪，我一读在读 却不得不承认 青春是一本太仓促的书","categories":[{"name":"LifeFeeling","slug":"LifeFeeling","permalink":"https://fantasylion.github.io/categories/LifeFeeling/"}],"tags":[{"name":"人生","slug":"人生","permalink":"https://fantasylion.github.io/tags/%E4%BA%BA%E7%94%9F/"}]},{"title":"MongoDB笔记1-安装运行MongoDB","slug":"2016-02-19-use-mongodb","date":"2016-02-18T16:00:00.000Z","updated":"2016-02-18T16:00:00.000Z","comments":true,"path":"database/2016-02-19-use-mongodb/","link":"","permalink":"https://fantasylion.github.io/database/2016-02-19-use-mongodb/","excerpt":"前段时间在上家公司做的产品后台用的就是Mongodb，由于当时这块根本接触不到，也一直没有时间去学习。趁现在在家呆着没事学习一下Mongodb。","text":"前言 前段时间在上家公司做的产品后台用的就是MongoDB，由于当时这块根本接触不到，也一直没有时间去学习。趁现在在家呆着没事学习一下MongoDB。 介绍 MongoDB是一个基于分布式文件存储的开源数据库系统，在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 正文 安装MongoDB 在安装MongoDB之前先要到__官网上下载__安装包 进去官网后选择自己的系统对应的版本下载，我这里用的是win7 64bit 所以选择 Windows 64-bit 2008 R2+, Legacy的版本是被放弃的版本不建议使用。 MongoDB对各系统平台的支持 Platform 3.2 3.0 2.6 2.4 2.2 Amazon Linux ✓ ✓ ✓ ✓ ✓ Debian 7 ✓ ✓ ✓ ✓ ✓ Fedora 8+ ✓ ✓ ✓ RHEL/CentOS 6.2+ ✓ ✓ ✓ ✓ ✓ RHEL/CentOS 7.0+ ✓ ✓ ✓ SLES 11 ✓ ✓ ✓ ✓ ✓ SLES 12 ✓ Solaris 64-bit ✓ ✓ ✓ ✓ ✓ Ubuntu 12.04 ✓ ✓ ✓ ✓ ✓ Ubuntu 14.04 ✓ ✓ ✓ Microsoft Azure ✓ ✓ ✓ ✓ ✓ Windows Vista/Server 2008R2/2012+ ✓ ✓ ✓ ✓ ✓ OSX 10.7+ ✓ ✓ ✓ ✓ 32位的MongoDB存在以下几个限制 不支持WiredTiger 存储引擎 默认日志是禁止的，因为日志会限制MongoDB可以存储的最大数据量 当运行的MongoDB，服务器的总存储大小，包括数据和索引，是2G字节。所以不要生产环境下使用在32位的MongoDB。 在下载完成后，windows版本直接下一步安装就可以了 安装完成之后MongoDB的目录是这样的 运行MongoDB 安装完成接下来要把MongoDB跑起来 在运行MongoDB之前先介绍一些刚安装MongoDB目录的lib目录下存放的文件作用 各可执行文件对应的作用 Component Set Binaries Server mongod.exe Router mongos.exe Client mongo.exe MonitoringTools mongostat.exe, mongotop.exe ImportExportTools mongodump.exe, mongorestore.exe, mongoexport.exe, mongoimport.exe MiscellaneousTools bsondump.exe, mongofiles.exe, mongooplog.exe, mongoperf.exe 首先得把MongoDB的Server端跑起来 在dos下敲下面的命令 12&#x2F;&#x2F;dbpath参数后面的跟的是数据库的路径，MongoDB默认有一个test库，参数可不加则直接使用默认的数据库mongod.exe --dbpath D:\\Tools\\Mongodb\\test\\data 这个时候Server端就会开启一个默认的端口27017，当然这个端口是可以通过参数更换的（加-h 就可以了解更多的参数）。 MongoDB在启动的时候需要知道数据库存储在哪个位置或者说将数据存储到哪，所以在启动的时候传入一个参数--dbpath告诉将要启动的MongoDB进程，数据库位置如果不指定的话则默认在/data/db位置去找，如果没有找到则将不能启动MongoDB。 在执行完上面的命令后，会出现The waiting for connections字样，说明服务器这个时候就已经开启了在等待一个客户端连接进来。 连接数据库 在数据库已经启动的情况下我们接下来就需要通过client去访问操作数据库。 在确保数据库已经启动成功，直接点击mongo.exe即可通过默认的端口连接到本地的数据库。如果你需要连接别的数据库，需要通过命令行传入指定参数进行连接。如： 12345mongo --username &lt;user&gt; --password &lt;pass&gt; --host &lt;host&gt; --port 28015或者mongo -u &lt;user&gt; -p &lt;pass&gt; --host &lt;host&gt; --port 28015 user：填入你在那台机器上的用户名 pass：填入你的用户密码 host：数据库主机地址 port：数据库开启的端口 当执行完命令后（或者直接点击mongo.exe）将会出现下方显示内容： 12342016-02-20T14:05.849+0800 I CONTROL [main] Hotfix KB271284 or later update is not installed, will zero-out data filesMongoDB shell version: 3.2.1connection to: test&gt; 下面执行一些简单的命令： 123456782016-02-20T14:05.849+0800 I CONTROL [main] Hotfix KB271284 or later update is not installed, will zero-out data filesMongoDB shell version: 3.2.1connection to: test&gt; dbtest&gt; show dbslocal 0.000GBtest 0.004GB db: 显示当前使用的是哪个数据库 show dbs: 显示有几个数据库","categories":[{"name":"database","slug":"database","permalink":"https://fantasylion.github.io/categories/database/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://fantasylion.github.io/tags/MongoDB/"}]},{"title":"使用 php printf() 和 sprintf() 格式化字符串","slug":"2016-01-23-Formating_PHP_Strings_With_Printf_And_Sprintf","date":"2016-01-22T16:00:00.000Z","updated":"2016-01-22T16:00:00.000Z","comments":true,"path":"translation/2016-01-23-Formating_PHP_Strings_With_Printf_And_Sprintf/","link":"","permalink":"https://fantasylion.github.io/translation/2016-01-23-Formating_PHP_Strings_With_Printf_And_Sprintf/","excerpt":"和其他许多编程语言一样, PHP 也有功能强大的 printf() 和 sprintf() 函数, 它们提供了很多格式化字符串的方式. 当你想要某些数据更易读, 或者需要传递数据给其他程式的时候, 这两个函数很有用. 这篇教程就会教你如何使用 printf() 和 sprintf() 来格式化字符串.","text":"原文在 2009/11/19 发表于 http://www.elated.com/articles/formatting-php-strings-printf-sprintf/ 和其他许多编程语言一样, PHP 也有功能强大的 printf() 和 sprintf() 函数, 它们提供了很多格式化字符串的方式. 当你想要某些数据更易读, 或者需要传递数据给其他程式的时候, 这两个函数很有用. PHP 也有许多专门用途的格式化字符串的函数 - 比如 date() 函数, 适合用于格式化日期字符串. 而 printf() 和 sprintf() 则适合更为通用的格式化. 这篇教程就会教你如何使用 printf() 和 sprintf() 来格式化字符串. #一个简单的 printf() 示例 了解 printf() 的最简单方式就是通过示例. 下面这个例子打印一个包含了两个数字的字符串: 1234&lt;?php// 打印 \"Australia comprises 6 states and 10 territories\"printf( \"Australia comprises %d states and %d territories\", 6, 10 );?&gt; 注意这个字符串在被打印出的时候, 第一个 %d 被第二个参数 6 替换, 第二个 %d 则被第三个参数 10 替换. 其工作原理即: 第一个参数必须是一个字符串, 我们称之为目标字符串. 目标字符串包含普通的字符, 和一些可选的格式说明符 (比如 %d) 所有格式说明符都以 % 开头. 它按对应的顺序以特定方式格式化目标字符串之后的参数, 然后将其插入到最终的字符串中, 并显示到网页. NOTE: 如果想要打印 % 符, 使用 %%. #类型说明符 上面那个例子使用的 %d 这个格式说明符, 会将参数按照有符号十进制数字格式化. 这个 d 被称为类型说明符. printf() 支持很多类型说明符. 下面是类型说明符的完整列表: 类型说明符 备注 b 将参数作为二进制数字(如 10010110)格式化 c 将参数作为 ASCII 码值格式化为对应的字符 d 将参数作为有符号十进制数字格式化 e 将参数作为科学计数法(如 1.234e+3)格式化 f 将参数作为浮点数字, 并且使用地区设定(如在法国, 逗号被用作小数点)格式化 F 和上面相同, 不过不使用地区设定 o 将参数作为八进制数字格式化 s 将参数作为字符串格式化 u 将参数作为无符号十进制数字格式化 x 将参数作为小写十六进制数字(如 4fdf87)格式化 X 将参数作为大写十六进制数字(如 4FDF87)格式化 下面是一些类型说明符的示例: 123&lt;?php printf( \"Here's the number %s as a float (%f), a binary integer (%b), an octal integer (%o), and a hex integer (%x).\", 543.21, 543.21, 543.21, 543.21, 543.21 );?&gt; 这段代码会输出: 1Here&#39;s the number 543.21 as a float (543.210000), a binary integer (1000011111), an octal integer (1037), and a hex integer (21f). #符号说明符 默认情况下, printf() 只会在负数前加正负符号: 1234&lt;?php printf( \"%d\", 36 ); // 输出 \"36\"printf( \"%d\", -36 ); // 输出 \"-36\"?&gt; 如果你也想让 printf() 在正数前加符号, 可以在类型说明符前指定一个符号说明符 +: 1234&lt;?php printf( \"%+d\", 36 ); // 输出 \"+36\"printf( \"%+d\", -36 ); // 输出 \"-36\"?&gt; #填充 printf() 允许你填充目标字符串到指定的长度. 你可以使用任何字符做填充字符, 也可以指定填充左边还是右边. 如果你希望在数字前补 0 或让字符串右对齐, 填充就派上用场了. 通过在 % 前面插入一个填充说明符来指定填充规则. 填充说明符使用以下格式: &lt;填充符&gt;&lt;宽度&gt;: &lt;填充符&gt; 可以是 0 或空格. 如果你不指定则默认使用空格. 如果你想要指定其他填充符, 需在它之前加一个 ' 字符. &lt;宽度&gt; 即想要填充到的宽度. 整数代表左填充, 负数代表右填充. 这是些填充说明符示例: 123456789&lt;?php printf( \"%04d\", 12 ); // 输出 \"0012\"printf( \"%04d\", 1234 ); // 输出 \"1234\"printf( \"%04d\", 12345 ); // 输出 \"12345\"printf( \"% 10s\", \"Hello\" ); // 输出 \" Hello\"printf( \"%10s\", \"Hello\" ); // 输出 \" Hello\"printf( \"%'*10s\", \"Hello\" ); // 输出 \"*****Hello\"printf( \"%'*-10s\", \"Hello\" ); // 输出 \"Hello*****\"?&gt; 留意第三个示例, 填充说明符并不会导致目标字符串被截断为 4 个字符. 填充只会在必要处增加字符 #数字精度 当使用 f 或者 F 类型说明符格式化浮点数时, PHP 默认会取到小数点后面 6 位: 123&lt;?php printf( \"%f\", 123.456 ); // 输出 \"123.456000\"?&gt; 如果要指定不同的精度, 就要用到精度说明符了. 精度说明符是一个 . 号后跟一个数字, 并应放到类型说明符之前. 如: 12345&lt;?php printf( \"%.2f\", 123.456 ); // 输出 \"123.46\"printf( \"%.10f\", 123.456 ); // 输出 \"123.4560000000\"printf( \"%.0f\", 123.456 ); // 输出 \"123\" ?&gt; 如果你既指定了填充说明符又指定了精度说明符, printf() 会将整个数字(包括整数和小数部分)填充到指定长度: 123&lt;?php printf( \"%08.2f\", 123.456 ); // 输出 \"00123.46\" ?&gt; 如果你同时使用 s 类型说明符和精度说明符, printf() 会截断目标字符串到指定的长度: 123&lt;?php printf( \"%.2s\", \"Hello\" ); // 输出 \"He\" ?&gt; #参数交换 默认情况下, 目标字符串的第一个格式说明符会格式化该字符串后的第一个参数, 目标字符串的第二个格式说明符会格式化该字符串后的第二个参数, 以此类推. 但是你可以更改这个顺序. 要这样做, 在 % 符和类型说明符之间插入一个 $ 号. 如: 1234&lt;?php // 输出 \"Australia comprises 10 territories and 6 states\"printf( 'Australia comprises %2$d territories and %1$d states', 6, 10 ); ?&gt; 在上面的例子中, 第一个格式说明符是 %2$d. 意即: “将目标字符串后的第二个参数作为十进制整数格式化”. 第二个格式说明符 %1$d 即: “将目标字符串后的第一个参数作为十进制整数格式化”. 这样, 参数便以不同与默认的顺序格式化. 在上面的例子中, 格式字符串使用单引号而非双引号包围. 这样是为了阻止 $ 符号被 PHP 解释为变量名. #保存格式化后的结果 那 sprintf() 又是干嘛的呢? 这个函数和 printf() 只有一点不同: 它会将格式化后的结果返回, 而不是直接输出. 这样你就可以将结果赋给变量, 进行其他操作等. 如果你想要在输出它之前进行额外的处理, 或者保存到数据库等, 那这点会很有用. 下面是示例: 123456&lt;?php $result = sprintf( \"Australia comprises %d states and %d territories\", 6, 10 );// 输出 \"Australia comprises 6 states and 10 territories\"echo $result; ?&gt; #相关函数 其他相关的函数包括 fprintf(), 用于将结果写到流(如文件). 还有 vprintf()/vsprintf()/vfprintf(), 它们使用一个数组参数, 而非参数列表.","categories":[{"name":"translation","slug":"translation","permalink":"https://fantasylion.github.io/categories/translation/"}],"tags":[{"name":"php","slug":"php","permalink":"https://fantasylion.github.io/tags/php/"}]},{"title":"ios微信上不能更换标题解决办法","slug":"2015-11-25-cant-modify-title-on-ios-wechat","date":"2015-11-24T16:00:00.000Z","updated":"2015-11-24T16:00:00.000Z","comments":true,"path":"program/2015-11-25-cant-modify-title-on-ios-wechat/","link":"","permalink":"https://fantasylion.github.io/program/2015-11-25-cant-modify-title-on-ios-wechat/","excerpt":"用Iphone手机的微信浏览网页的时候，在切换页面时无法更新页面的title。于是从网上找了一个传说中的黑魔法解决此问题。","text":"背景 用Iphone手机的微信浏览网页的时候，在切换页面时无法更新页面的title。于是从网上找了一个传说中的黑魔法解决此问题。 使用jQuery 1234567891011121314151617var$body &#x3D; $(&#39;body&#39;);document.title &#x3D; &#39;title&#39;;&#x2F;&#x2F; hack在微信等webview中无法修改document.title的情况var$iframe &#x3D; $(&#39;&lt;iframe src&#x3D;&quot;&#x2F;favicon.ico&quot;&gt;&lt;&#x2F;iframe&gt;&#39;);$iframe.on(&#39;load&#39;,function()&#123; setTimeout(function()&#123; $iframe.off(&#39;load&#39;).remove(); &#125;, 0);&#125;).appendTo($body); 原生javaScript 123456789101112131415161718192021var body &#x3D; document.getElementsByTagName(&#39;body&#39;)[0];document.title &#x3D; &quot;标题被我改了&quot;;var iframe &#x3D; document.createElement(&quot;iframe&quot;);iframe.setAttribute(&quot;src&quot;, &quot;loading.png&quot;);iframe.addEventListener(&#39;load&#39;, function()&#123;setTimeout(function()&#123; iframe.removeEventListener(&#39;load&#39;); document.body.removeChild(iframe); &#125;, 0);&#125;);document.body.appendChild(iframe);","categories":[{"name":"program","slug":"program","permalink":"https://fantasylion.github.io/categories/program/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://fantasylion.github.io/tags/JavaScript/"}]},{"title":"YII(版本1) 权威指南学习笔记(未完结)","slug":"2015-11-19-learning-note-YII(1.1)","date":"2015-11-18T16:00:00.000Z","updated":"2015-11-18T16:00:00.000Z","comments":true,"path":"notes/2015-11-19-learning-note-YII(1.1)/","link":"","permalink":"https://fantasylion.github.io/notes/2015-11-19-learning-note-YII(1.1)/","excerpt":"Yii 是一个基于组件的高性能 PHP 框架, 用于快速开发大型 Web 应用. 它使 Web 开发中的 可复用度最大化, 可以显著提高你的 Web 应用开发速度. Yii 这个名字(读作易(Yee) 或 [ji:])代表 简单(easy), 高效(efficient) 和 可扩展(extensible).","text":"#基础 ##入口脚本 WEB 应用一般为 index.php, 控制台应用一般为 yii.php 并在文件开头加上 #! /usr/bin/env php 入口脚本是定义全局常量的好地方 支持三个常量: YII_DEBUG, YII_ENV, YII_ENABLE_ERROR_HANDLER WEB: 12345678910111213141516&lt;?php// 定义全局常量defined('YII_DEBUG') or define('YII_DEBUG', true);defined('YII_ENV') or define('YII_ENV', 'dev');// 注册 Composer 自动加载器require(__DIR__ . '/../vendor/autoload.php');// 包含 Yii 类文件require(__DIR__ . '/../vendor/yiisoft/yii2/Yii.php');// 加载应用配置$config = require(__DIR__ . '/../config/web.php');// 创建、配置、运行一个应用(new yii\\web\\Application($config))-&gt;run(); 控制台: 123456789101112131415161718192021#!/usr/bin/env php&lt;?phpdefined('YII_DEBUG') or define('YII_DEBUG', true);// fcgi 默认没有定义 STDIN 和 STDOUTdefined('STDIN') or define('STDIN', fopen('php://stdin', 'r'));defined('STDOUT') or define('STDOUT', fopen('php://stdout', 'w'));// 注册 Composer 自动加载器require(__DIR__ . '/vendor/autoload.php');// 包含 Yii 类文件require(__DIR__ . '/vendor/yiisoft/yii2/Yii.php');// 加载应用配置$config = require(__DIR__ . '/config/console.php');$application = new yii\\console\\Application($config);$exitCode = $application-&gt;run();exit($exitCode);?&gt; ##应用主体 创建: Yii::createWebApplication($configFile) 访问: 可以在任何地方使用 Yii::app()|YiiBase::app 访问 ##控制器 控制器路由格式: moduleID/controllerID/actionID 控制器创建决策步骤: 如果指定了 CWebApplication::catchAllRequest, 用户指定的 ID 将被忽略. (通常用于设置应用为维护状态, 显示一个静态页面) 如果在 CWebApplication::controllerMap 中找到 ID, 相应的控制器配置则被用于创建控制器 如果 ID 为 path/to/xyz 形式, 则按控制器路由格式解析并创建 创建: 默认控制器在 CWebApplication::defaultController 中定义, 默认动作为 index, 对应的方法名为 actionIndex, 可通过 CController::defaultAction 修改 1234&lt;?phpclass SiteController extends CController &#123;&#125;?&gt; 也可以由一个动作类来定义动作, 以便重用动作: 1234567&lt;?phpclass UpdateAction extends CAction &#123; public function run() &#123; // place the action logic here &#125;&#125;?&gt; 然后需覆盖控制器类的 actions 方法: 123456789&lt;?phpclass PostController extends CController &#123; public function actions() &#123; return array( 'edit'=&gt;'application.controllers.post.UpdateAction', ); &#125;&#125;?&gt; 动作参数绑定: 123456789&lt;?php// in PostController:public function actionCreate(array $category, $language = 'en') &#123; // 动作参数绑定功能将会把传入 action 的参数和 $_GET 中的数据绑定 // 在此, 如果 $_GET 中没有 language 这一项, $language 默认为 'en' // 因为没有为 $category 提供默认值, 如果 $_GET 中没有 category 这一项则会报错 // array 类型声明会确保 $category 为一个数组(自动将基本类型转换为数组)&#125;?&gt; 过滤器可被配置在动作执行之前或之后执行, 如访问控制过滤器, 性能过滤器(参见访问控制过滤器) 定义: 可被定义为一个 filter 前缀的控制器方法: 12345&lt;?phppublic function filterAccessControl($filterChain) &#123; // 调用 $filterChain-&gt;run() 以继续后续过滤器与动作的执行。&#125;?&gt; 也可是一个 CFilter 或其子类的实例: 123456789101112&lt;?phpclass PerformanceFilter extends CFilter &#123; protected function preFilter($filterChain) &#123; // 动作被执行之前应用的逻辑 return true; // 如果动作不应被执行，此处返回 false &#125; protected function postFilter($filterChain) &#123; // 动作执行之后应用的逻辑 &#125;&#125;?&gt; 配置使用: 需要覆盖控制器的 filter() 方法: 1234567891011121314&lt;?phpclass PostController extends CController &#123; ...... public function filters() &#123; return array( 'postOnly + edit, create', // 使用 filter 前缀方法定义的过滤器 array( // 使用类定义的过滤器 'application.filters.PerformanceFilter - edit, create', 'unit'=&gt;'second', ), ); &#125;&#125;?&gt; ##模型 Yii 实现了两种类型的模型: 表单模型和 Active Record, 二者都继承于 CModel 如果用户输入被收集然后丢弃, 应该创建一个表单模型; 如果用户输入被收集后要保存到数据库, 应使用一个 Active Record 详见表单模型和Active Record ##视图 CController::render('edit') 将会在 protected/views/ControllerID 目录下寻找 edit.php 视图文件 可以通过在视图中使用 $this-&gt;propertyName 访问控制器的任何属性, 也可以在控制器中将数据传递到视图中: 123456&lt;?php$this-&gt;render('edit', array( 'var1'=&gt;$value1, 'var2'=&gt;$value2,));?&gt; protected/views/layouts/main.php 是默认的布局文件, 可通过 CWebApplication::layout 自定义. 要渲染一个不带布局的视图, 需调用 CController::renderPartial 小物件是 CWidget 或其子类的实例, 它也可以有自己的视图文件 定义 1234567891011&lt;?phpclass MyWidget extends CWidget &#123; public function init() &#123; // 此方法会被 CController::beginWidget() 调用 &#125; public function run() &#123; // 此方法会被 CController::endWidget() 调用 &#125;&#125;?&gt; 按如下视图脚本来使用一个小物件: 12345&lt;?php $this-&gt;beginWidget('path.to.WidgetClass', $config); ?&gt;...可能会由小物件获取的内容主体...&lt;?php $this-&gt;endWidget(); ?&gt;// 或&lt;?php $this-&gt;widget('path.to.WidgetClass', $config); ?&gt; 系统视图用于展示 Yii 的错误和日志消息, 如如果 CHttpException 抛出一个 404 错误, 那么 error404 就会被展示. Yii 在 framework/views 下提供了默认的系统视图, 也可以通过在 protected/views/system 下创建同名视图文件进行自定义 ##组件 加载: 通过配置应用的 components|CApplication::components 属性 可以配置 enabled 为 false 禁用组件 组件是按需创建的, 但是可以将组件 ID 列入应用的 preload|CWebApplication::preload 属性中强制其加载 访问: Yii::app()-&gt;ComponentID 预定义的核心应用组件: assetManager authManager cache clientScript coreMessage db errorHandler format messages request securityManager session statePersister urlManager user themeManager 组件属性 可以通过直接定义一个公共成员变量定义 也可以使用 getter 和 setter 更灵活的定义 通过 getter 和 setter 定义的属性和类成员变量有个区别: 他们是不区分大小写的 组件事件 定义组件事件(on 开头) 12345&lt;?phppublic function onClicked($event) &#123; $this-&gt;raiseEvent('onClicked', $event);&#125;?&gt; 定义事件回调 12345&lt;?phpfunction callbackName($event) &#123; ......&#125;?&gt; 绑定事件回调 123456&lt;?php$component-&gt;onClicked=$callback;// 或使用匿名函数$component-&gt;onclicked=function($event) &#123;&#125;?&gt; 组件行为 行为类必须实现 IBehavior 大多数行为可继承自 CBehavior, 如果行为需要绑定到模型, 则也可以继承自 CModelBehavior 或 CActiveRecordBehavior 两个同名行为绑定到同一个组件下是有可能的, 在这种情况下, 先绑定的行为则拥有优先权 当和 events, 一起使用时, 行为会更加强大. 当行为被绑定到组件时,行为里的一些方法就可以绑定到组件的一些事件上了. 这样一来,行为就有机观察或者改变组件的常规执行流程 一个行为的属性也可以通过绑定到的组件来访问. 这些属性包含公共成员变量以及通过 getters 和/或 setters 方式设置的属性. 例如, 若一个行为有一个 xyz 的属性，此行为被绑定到组件 $a, 然后我们可以使用表达式 $a-&gt;xyz 访问此行为的属性 绑定行为: 123456&lt;?php// $name 在组件中实现了对行为的唯一识别$component-&gt;attachBehavior($name,$behavior);// test() 是行为中的方法。$component-&gt;test();?&gt; 访问行为: 12345&lt;?php$behavior=$component-&gt;tree;// 等于下行代码：// $behavior=$component-&gt;asa('tree');?&gt; 禁用行为: 12345678&lt;?php$component-&gt;disableBehavior($name);// 下面的代码将抛出一个异常$component-&gt;test();$component-&gt;enableBehavior($name);// 现在就可以使用了$component-&gt;test();?&gt; ##模块 模块是一个独立的软件单元，它包含 模型, 视图, 控制器 和其他支持的组件. 如 forum 模块的典型目录结构 forum/ ForumModule.php 模块类文件 components/ 包含可复用的用户组件 views/ 包含小物件的视图文件 controllers/ 包含控制器类文件 DefaultController.php 默认的控制器类文件 extensions/ 包含第三方扩展 models/ 包含模块类文件 views/ 包含控制器视图和布局文件 layouts/ 包含布局文件 default/ 包含 DefaultController 的视图文件 index.php 首页视图文件 模块可以嵌套 使用模块: 继承 CWebModule, 并命名为 ucfirst($id).‘Module’ 将模块目录放入 modules 目录中, 然后在应用的 modules 配置 属性中声明模块 ID. 模块也可以在配置是带有初始属性值 使用 CController::module 访问 ##路径别名和名字空间 YiiBase::getPathOfAlias() 获取别名的真实路径, YiiBase::setPathOfAlias() 设置新的别名的真实路径 预定义的根别名 system zii application webroot ext 模块 ID 使用别名导入类: Yii::import('system.web.CController'). (所有核心类已被预先导入) 预导入: 在 CWebApplication::run() 之前执行: 1234567&lt;?phpYii::$classMap=array( 'ClassName1' =&gt; 'path/to/ClassName1.php', 'ClassName2' =&gt; 'path/to/ClassName2.php', ......);?&gt; 导入目录: Yii::import('system.web.*'); #使用表单 ##创建模型 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclass LoginForm extends CFormModel &#123; // 定义特性(我们把用于存储用户输入或数据库数据的属性成为特性(attribute)) public $username; public $password; public $rememberMe=false; private $_identity; // 验证规则 public function rules() &#123; /** * 每个验证规则的格式为: * array('AttributeList', 'Validator', 'on'=&gt;'ScenarioList', ...附加选项) * 有三种方法指定 Validator * 1. 指定为模型类中的一个方法, 该方法定义格式为 * public function ValidatiorName($attributes, $params) &#123;...&#125; * 2. 一个继承自 CValidator 的验证器类, 此时附加选项用于初始化实例的属性值 * 3. 一个预定义的验证器类的别名, 以下是完整列表 * boolean, captcha, compare, email, default, exists, file * filter, in, length, match, numerical, required, type, unique, url */ return array( array('username, password', 'required'), // 必填 array('rememberMe', 'boolean'), // 布尔 array('password', 'authenticate'), // 需验证 ); &#125; /** * authenticate Validator */ public function authenticate($attribute,$params) &#123; $this-&gt;_identity=new UserIdentity($this-&gt;username,$this-&gt;password); if(!$this-&gt;_identity-&gt;authenticate()) $this-&gt;addError('password','错误的用户名或密码。'); &#125;&#125;?&gt; 块赋值(massive assignment) 12345678910111213&lt;?php$model = new LoginForm();if (isset($_POST['LoginForm'])) &#123; /** * 只有被认为 '安全' 的特性才会被赋值 * 特性如果出现在相应场景的一个验证规则中, 即被认为是安全的 * 也可以用特殊的 `safe` Validator 来让特性变为安全的 * * 为了使块赋值正确工作, 对应于模型类 `C` 中的特性 `a` 的表单域, 请命名其为 `C[a]` */ $model-&gt;attributes = $_POST['LoginForm'];&#125;?&gt; 触发验证 验证是基于 场景(scenario) 的 可以手动调用 CModel::validate() 触发; 对于 CActiveRecord, 会在 CAcitveRecord::save() 时自动触发验证 验证错误可以使用 CModel::getError() 或 CModel::getErrors() 获取 标签 CModel 默认将返回特性的名字作为其标签 也可使用 CModel::attributesLabels 方法自定义标签 ##创建动作 1234567891011121314&lt;?phppublic function actionLogin() &#123; $model=new LoginForm; if(isset($_POST['LoginForm'])) &#123; // 收集用户输入的数据 $model-&gt;attributes=$_POST['LoginForm']; // 验证用户输入，并在判断输入正确后重定向到前一页 if($model-&gt;validate()) $this-&gt;redirect(Yii::app()-&gt;user-&gt;returnUrl); &#125; // 显示登录表单 $this-&gt;render('login',array('model'=&gt;$model));&#125;?&gt; ##创建视图 1234567891011121314151617181920212223242526&lt;div class=\"form\"&gt;&lt;?php $form=$this-&gt;beginWidget('CActiveForm'); ?&gt; &lt;?php echo $form-&gt;errorSummary($model); ?&gt; &lt;div class=\"row\"&gt; &lt;?php echo $form-&gt;label($model,'username'); ?&gt; &lt;?php echo $form-&gt;textField($model,'username') ?&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;?php echo $form-&gt;label($model,'password'); ?&gt; &lt;?php echo $form-&gt;passwordField($model,'password') ?&gt; &lt;/div&gt; &lt;div class=\"row rememberMe\"&gt; &lt;?php echo $form-&gt;checkBox($model,'rememberMe'); ?&gt; &lt;?php echo $form-&gt;label($model,'rememberMe'); ?&gt; &lt;/div&gt; &lt;div class=\"row submit\"&gt; &lt;?php echo CHtml::submitButton('Login'); ?&gt; &lt;/div&gt;&lt;?php $this-&gt;endWidget(); ?&gt;&lt;/div&gt;&lt;!-- form --&gt; ##收集表格输入(批量) action: 12345678910111213141516171819202122&lt;?phppublic function actionBatchUpdate()&#123; // 假设每一项（item）是一个 'Item' 类的实例， // 提取要通过批量模式更新的项 $items=$this-&gt;getItemsToUpdate(); if(isset($_POST['Item'])) &#123; $valid=true; foreach($items as $i=&gt;$item) &#123; if(isset($_POST['Item'][$i])) $item-&gt;attributes=$_POST['Item'][$i]; $valid=$valid &amp;&amp; $item-&gt;validate(); &#125; if($valid) // 如果所有项目有效 // ...则在此处做一些操作 &#125; // 显示视图收集表格输入 $this-&gt;render('batchUpdate',array('items'=&gt;$items));&#125;?&gt; view: 1234567891011121314151617&lt;div class=\"form\"&gt;&lt;?php echo CHtml::beginForm(); ?&gt;&lt;table&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Price&lt;/th&gt;&lt;th&gt;Count&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;&lt;?php foreach($items as $i=&gt;$item): ?&gt;&lt;tr&gt;&lt;td&gt;&lt;?php echo CHtml::activeTextField($item,\"[$i]name\"); ?&gt;&lt;/td&gt;&lt;td&gt;&lt;?php echo CHtml::activeTextField($item,\"[$i]price\"); ?&gt;&lt;/td&gt;&lt;td&gt;&lt;?php echo CHtml::activeTextField($item,\"[$i]count\"); ?&gt;&lt;/td&gt;&lt;td&gt;&lt;?php echo CHtml::activeTextArea($item,\"[$i]description\"); ?&gt;&lt;/td&gt;&lt;/tr&gt;&lt;?php endforeach; ?&gt;&lt;/table&gt;&lt;?php echo CHtml::submitButton('Save'); ?&gt;&lt;?php echo CHtml::endForm(); ?&gt;&lt;/div&gt; ##使用表单生成器 @todo action: 1234567891011&lt;?phppublic function actionLogin() &#123; $model = new LoginForm; $form = new CForm('application.views.site.loginForm', $model); if($form-&gt;submitted('login') &amp;&amp; $form-&gt;validate()) &#123; $this-&gt;redirect(array('site/index')); &#125; else &#123; $this-&gt;render('login', array('form'=&gt;$form)); &#125;&#125;?&gt; protected/views/site/loginForm.php: 12345678910111213141516171819202122232425262728&lt;?phpreturn array( 'title'=&gt;'Please provide your login credential', 'elements'=&gt;array( 'username'=&gt;array( // 可选 type: text, hidden, password, textarea, file, radio // checkbox, listbox, dropdownlist, checkboxlist, radiolist 'type'=&gt;'text', 'maxlength'=&gt;32, ), 'password'=&gt;array( 'type'=&gt;'password', 'maxlength'=&gt;32, ), 'rememberMe'=&gt;array( 'type'=&gt;'checkbox', ) ), 'buttons'=&gt;array( 'login'=&gt;array( 'type'=&gt;'submit', 'label'=&gt;'Login', ), ),);?&gt; view: 12345&lt;h1&gt;Login&lt;/h1&gt;&lt;div class=\"form\"&gt;&lt;?php echo $form; ?&gt;&lt;/div&gt; #使用数据库 ##数据访问对象(DAO) 建立数据库连接: 使用 CDbConnection: 1234567&lt;?php$connection=new CDbConnection($dsn,$username,$password);// 建立连接。你可以使用 try...catch 捕获可能抛出的异常$connection-&gt;active=true;......$connection-&gt;active=false; // 关闭连接?&gt; 作为应用组件配置, 然后使用 Yii::app()-&gt;db 访问 123456789101112131415&lt;?phparray( ...... 'components'=&gt;array( ...... 'db'=&gt;array( 'class'=&gt;'CDbConnection', 'connectionString'=&gt;'mysql:host=localhost;dbname=testdb', 'username'=&gt;'root', 'password'=&gt;'password', 'emulatePrepare'=&gt;true, // needed by some MySQL installations ), ),)?&gt; ##执行 SQL 语句 创建 CDbCommand 实例 12345678&lt;?php$connection=Yii::app()-&gt;db; // 假设你已经建立了一个 \"db\" 连接// 如果没有，你可能需要显式建立一个连接：// $connection=new CDbConnection($dsn,$username,$password);$command=$connection-&gt;createCommand($sql);// 如果需要，此 SQL 语句可通过如下方式修改：// $command-&gt;text=$newSQL;?&gt; 使用以下方法执行语句 12345678&lt;?php$rowCount=$command-&gt;execute(); // 执行无查询 SQL(Insert, delete, update)$dataReader=$command-&gt;query(); // 执行一个 SQL 查询(select), 返回 CDbDataReader 实例$rows=$command-&gt;queryAll(); // 查询并返回结果中的所有行$row=$command-&gt;queryRow(); // 查询并返回结果中的第一行$column=$command-&gt;queryColumn(); // 查询并返回结果中的第一列$value=$command-&gt;queryScalar(); // 查询并返回结果中第一行的第一个字段?&gt; 获取查询结果 123456789&lt;?php$dataReader=$command-&gt;query();// 重复调用 read() 直到它返回 falsewhile(($row=$dataReader-&gt;read())!==false) &#123; ... &#125;// 或使用 foreach 遍历数据中的每一行foreach($dataReader as $row) &#123; ... &#125;// 一次性提取所有行到一个数组$rows=$dataReader-&gt;readAll();?&gt; 使用事务 1234567891011&lt;?php$transaction=$connection-&gt;beginTransaction();try &#123; $connection-&gt;createCommand($sql1)-&gt;execute(); $connection-&gt;createCommand($sql2)-&gt;execute(); //.... other SQL executions $transaction-&gt;commit();&#125; catch(Exception $e) &#123; // 如果有一条查询失败，则会抛出异常 $transaction-&gt;rollBack();&#125;?&gt; 使用 Prepare Statment 1234567891011121314&lt;?php// 一条带有两个占位符 \":username\" 和 \":email\"的 SQL$sql=\"INSERT INTO tbl_user (username, email) VALUES(:username,:email)\";$command=$connection-&gt;createCommand($sql);// 用实际的用户名替换占位符 \":username\" $command-&gt;bindParam(\":username\",$username,PDO::PARAM_STR);// 用实际的 Email 替换占位符 \":email\" $command-&gt;bindParam(\":email\",$email,PDO::PARAM_STR);$command-&gt;execute();// 使用新的参数集插入另一行$command-&gt;bindParam(\":username\",$username2,PDO::PARAM_STR);$command-&gt;bindParam(\":email\",$email2,PDO::PARAM_STR);$command-&gt;execute();?&gt; 绑定结果列 1234567891011&lt;?php$sql=\"SELECT username, email FROM tbl_user\";$dataReader=$connection-&gt;createCommand($sql)-&gt;query();// 使用 $username 变量绑定第一列 (username) $dataReader-&gt;bindColumn(1,$username);// 使用 $email 变量绑定第二列 (email) $dataReader-&gt;bindColumn(2,$email);while($dataReader-&gt;read()!==false) &#123; // $username 和 $email 含有当前行中的 username 和 email &#125;?&gt; 使用表前缀 配置 CDbConnection::tablePrefix 属性为所希望的表前缀, 然后便可以在 SQL 语句中使用 代表表的名字 ##查询构建器 查询构建器构建于一个 CDbCommand 实例上 查询构建器不能用于修改一个已经存在的 SQL 查询 可用的查询构建器示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;?php// 1. 数据查询// SELECT *select()// SELECT `id`, `username`select('id, username')// SELECT `tbl_user`.`id`, `username` AS `name`select('tbl_user.id, username as name')// SELECT `id`, `username`select(array('id', 'username'))// SELECT `id`, count(*) as numselect(array('id', 'count(*) as num'))// SELECT DISTINCT `id`, `username`selectDistinct('id, username')// FROM `tbl_user`from('tbl_user')// FROM `tbl_user` `u`, `public`.`tbl_profile` `p`from('tbl_user u, public.tbl_profile p')// FROM `tbl_user`, `tbl_profile`from(array('tbl_user', 'tbl_profile'))// FROM `tbl_user`, (select * from tbl_profile) pfrom(array('tbl_user', '(select * from tbl_profile) p'))// WHERE id=1 or id=2where('id=1 or id=2')// WHERE id=:id1 or id=:id2where('id=:id1 or id=:id2', array(':id1'=&gt;1, ':id2'=&gt;2))// WHERE id=1 OR id=2where(array('or', 'id=1', 'id=2'))// WHERE id=1 AND (type=2 OR type=3)where(array('and', 'id=1', array('or', 'type=2', 'type=3')))// WHERE `id` IN (1, 2)where(array('in', 'id', array(1, 2))// WHERE `id` NOT IN (1, 2)where(array('not in', 'id', array(1,2)))// when using LIKE, remember to escape user inputed `%` and `_`// WHERE `name` LIKE '%Qiang%'where(array('like', 'name', '%Qiang%'))// WHERE `name` LIKE '%Qiang' AND `name` LIKE '%Xue'where(array('like', 'name', array('%Qiang', '%Xue')))// WHERE `name` LIKE '%Qiang' OR `name` LIKE '%Xue'where(array('or like', 'name', array('%Qiang', '%Xue')))// WHERE `name` NOT LIKE '%Qiang%'where(array('not like', 'name', '%Qiang%'))// WHERE `name` NOT LIKE '%Qiang%' OR `name` NOT LIKE '%Xue%'where(array('or not like', 'name', array('%Qiang%', '%Xue%')))// WHERE ... OR ...orWhere()// WHERE ... AND ...andWhere()// ORDER BY `name`, `id` DESCorder('name, id desc')// ORDER BY `tbl_profile`.`name`, `id` DESCorder(array('tbl_profile.name', 'id desc'))// LIMIT 10limit(10)// LIMIT 10 OFFSET 20limit(10, 20)// OFFSET 20offset(20)// JOIN `tbl_profile` ON user_id=idjoin('tbl_profile', 'user_id=id')// LEFT JOIN `pub`.`tbl_profile` `p` ON p.user_id=id AND type=1leftJoin('pub.tbl_profile p', 'p.user_id=id AND type=:type', array(':type'=&gt;1))// RIGHT JOINrightJoin()// CROSS JOINcrossJoin()// NATURAL JOINnatrualJoin()// GROUP BY `name`, `id`group('name, id')// GROUP BY `tbl_profile`.`name`, `id`group(array('tbl_profile.name', 'id'))// HAVING id=1 or id=2having('id=1 or id=2')// HAVING id=1 OR id=2having(array('or', 'id=1', 'id=2'))// UNION (select * from tbl_profile)union('select * from tbl_profile')// 2. 数据操作(不同于数据查询, 数据操作会立即执行)// INSERT INTO `tbl_user` (`name`, `email`) VALUES (:name, :email)$command-&gt;insert('tbl_user', array( 'name'=&gt;'Tester', 'email'=&gt;'tester@example.com',));// UPDATE `tbl_user` SET `name`=:name WHERE id=:id$command-&gt;update('tbl_user', array( 'name'=&gt;'Tester',), 'id=:id', array(':id'=&gt;1));// DELETE FROM `tbl_user` WHERE id=:id$command-&gt;delete('tbl_user', 'id=:id', array(':id'=&gt;1));// 3. Schema 操作// CREATE TABLE `tbl_user` (// `id` int(11) NOT NULL AUTO_INCREMENT PRIMARY KEY,// `username` varchar(255) NOT NULL,// `location` point// ) ENGINE=InnoDBcreateTable('tbl_user', array( 'id' =&gt; 'pk', 'username' =&gt; 'string NOT NULL', 'location' =&gt; 'point',), 'ENGINE=InnoDB')// RENAME TABLE `tbl_users` TO `tbl_user`renameTable('tbl_users', 'tbl_user')// DROP TABLE `tbl_user`dropTable('tbl_user')// TRUNCATE TABLE `tbl_user`truncateTable('tbl_user')// ALTER TABLE `tbl_user` ADD `email` varchar(255) NOT NULLaddColumn('tbl_user', 'email', 'string NOT NULL')// ALTER TABLE `tbl_user` DROP COLUMN `location`dropColumn('tbl_user', 'location')// ALTER TABLE `tbl_users` CHANGE `name` `username` varchar(255) NOT NULLrenameColumn('tbl_user', 'name', 'username')// ALTER TABLE `tbl_user` CHANGE `username` `username` varchar(255) NOT NULLalterColumn('tbl_user', 'username', 'string NOT NULL')// ALTER TABLE `tbl_profile` ADD CONSTRAINT `fk_profile_user_id`// FOREIGN KEY (`user_id`) REFERENCES `tbl_user` (`id`)// ON DELETE CASCADE ON UPDATE CASCADEaddForeignKey('fk_profile_user_id', 'tbl_profile', 'user_id', 'tbl_user', 'id', 'CASCADE', 'CASCADE')// ALTER TABLE `tbl_profile` DROP FOREIGN KEY `fk_profile_user_id`dropForeignKey('fk_profile_user_id', 'tbl_profile')// CREATE INDEX `idx_username` ON `tbl_user` (`username`)createIndex('idx_username', 'tbl_user', 'username')// DROP INDEX `idx_username` ON `tbl_user`dropIndex('idx_username', 'tbl_user')?&gt; 也可通过使用属性赋值方式: 123&lt;?php$command-&gt;select = array('id', 'username');?&gt; 或在创建 CDbCommand 是传配置参数的方式构建: 12345678&lt;?php$row = Yii::app()-&gt;db-&gt;createCommand(array( 'select' =&gt; array('id', 'username'), 'from' =&gt; 'tbl_user', 'where' =&gt; 'id=:id', 'params' =&gt; array(':id'=&gt;1),))-&gt;queryRow();?&gt; 构建完成后, 可以使用在执行 SQL 语句中讲到的方法执行之; 也可使用 CDbCommand::getText() 获取最后构建完工后的 SQL 语句, 绑定的参数被保存在 CDbCommand::params 中 同一个 CDbCommand 实例可用于多次构建不同的查询, 但是记得要再另一次之前调用 CDbCommand::reset() 以清理上次的查询 ##Active Record 每个 AR 类代表一个数据表(或视图), 数据表(或视图)的列在 AR 类中体现为类的属性, 一个 AR 实例则表示表中的一行 最佳应用是模型化数据表为 PHP 结构和执行不包含复杂 SQL 语句的查询. 对于复杂查询的场景, 应使用 Yii DAO 如果你数据库的表结构很少改动, 你应该通过配置 CDbConnection::schemaCachingDuration 属性的值为一个大于零的值开启表结构缓存 通过 AR 使用多个数据库有两种方式. 如果数据库的结构不同, 你可以创建不同的 AR 基类实现不同的 getDbConnection(); 否则, 动态改变静态变量 CActiveRecord::db 是一个好主意 由于 AR 类经常在多处被引用, 我们可以导入包含 AR 类的整个目录, 而不是一个个导入. 见路径别名和命名空间 通过 Yii 的日志功能, 可以查看 AR 在背后到底执行了那些语句 定义 AR 类: 1234567891011121314151617181920212223&lt;?phpclass Post extends CActiveRecord &#123; public static function model($className=__CLASS__) &#123; return parent::model($className); &#125; /** * 默认情况下, AR 类的名字和数据表的名字相同. 如果不同, 请覆盖 `CActiveRecord::tableName` 方法 */ public function tableName() &#123; return 'tbl_post'; &#125; /** * AR 依靠表中良好定义的主键. 如果一个表没有主键，则必须在相应的 AR 类中通过如下方式覆盖 primaryKey() 方法指定哪一列或哪几列作为主键: */ public function primaryKey() &#123; return 'id'; // 对于复合主键，要返回一个类似如下的数组 // return array('pk1', 'pk2'); &#125;&#125;?&gt; 创建记录: 如果表的主键是自增的, 在插入完成后, AR 实例将包含一个更新的主键 12345678&lt;?php$post=new Post;$post-&gt;title='sample post';$post-&gt;content='content for the sample post';// 如果要使用 Mysql 的 NOW(), 必须使用 CDbExpression, 单纯的 'NOW()' 将会被作为字符串对待$post-&gt;create_time=new CDbExpression('NOW()');$post-&gt;save();?&gt; 读取记录: find 系列返回一个 AR 实例, 或者 null findAll 系列返回 AR 实例数组, 或者空数组 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php// 1. 常规// 查找满足指定条件的结果中的第一行$post=Post::model()-&gt;find($condition,$params);$post=Post::model()-&gt;find('postID=:postID', array(':postID'=&gt;10));// 查找具有指定主键值的那一行$post=Post::model()-&gt;findByPk($postID,$condition,$params);// 查找具有指定属性值的行$post=Post::model()-&gt;findByAttributes($attributes,$condition,$params);// 通过指定的 SQL 语句查找结果中的第一行$post=Post::model()-&gt;findBySql($sql,$params);// 查找满足指定条件的所有行$posts=Post::model()-&gt;findAll($condition,$params);// 查找带有指定主键的所有行$posts=Post::model()-&gt;findAllByPk($postIDs,$condition,$params);// 查找带有指定属性值的所有行$posts=Post::model()-&gt;findAllByAttributes($attributes,$condition,$params);// 通过指定的SQL语句查找所有行$posts=Post::model()-&gt;findAllBySql($sql,$params);// 获取满足指定条件的行数$n=Post::model()-&gt;count($condition,$params);// 通过指定的 SQL 获取结果行数$n=Post::model()-&gt;countBySql($sql,$params);// 检查是否至少有一行复合指定的条件$exists=Post::model()-&gt;exists($condition,$params);// 2. 使用 `CDbCriteria`$criteria=new CDbCriteria;$criteria-&gt;select='title'; // 只选择 'title' 列$criteria-&gt;condition='postID=:postID';$criteria-&gt;params=array(':postID'=&gt;10);$post=Post::model()-&gt;find($criteria); // $params 不需要了// 3. 传递数组$post=Post::model()-&gt;find(array( 'select'=&gt;'title', 'condition'=&gt;'postID=:postID', 'params'=&gt;array(':postID'=&gt;10),));?&gt; 更新记录: 如果一个 AR 实例是使用 new 操作符创建的, 调用 CActiveRecord::save 将会向数据表中插入一行新数据; 如果 AR 实例是某个 find 或 findAll 方法的结果, 调用 CActiveRecord::save 将更新表中现有的行. 实际上, 我们是使用 CActiveRecord::isNewRecord 说明一个 AR 实例是不是新的 直接更新数据表中的一行或多行而不首先载入也是可行的: 12345678&lt;?php// 更新符合指定条件的行Post::model()-&gt;updateAll($attributes,$condition,$params);// 更新符合指定条件和主键的行Post::model()-&gt;updateByPk($pk,$attributes,$condition,$params);// 更新满足指定条件的行的计数列Post::model()-&gt;updateCounters($counters,$condition,$params);?&gt; 删除记录: 实例化后删除: 这样删除之后, AR 实例仍不改变 1234&lt;?php$post=Post::model()-&gt;findByPk(10); // 假设有一个帖子，其 ID 为 10$post-&gt;delete(); // 从数据表中删除此行?&gt; 不实例化直接删除 123456&lt;?php// 删除符合指定条件的行Post::model()-&gt;deleteAll($condition,$params);// 删除符合指定条件和主键的行Post::model()-&gt;deleteByPk($pk,$condition,$params);?&gt; 如果要确定两个 AR 是否是同一个记录, 只需对比它们的主键值, 或直接调用 CActiveRecord::equals() 通过以下几个占位符方法, 可以自定义 AR 的工作流: 占位符方法 含义 beforeValidate, afterValidate 在验证之前(后)执行 beforeSave, afterSave 在保存 AR 实例之前(后)执行 beforeFind, afterFind 在执行查询之前(后)执行 afterConstruct 在 AR 实例化之后执行 数据验证和块赋值参见触发验证和块赋值 事务处理, 参见使用事务 1234567891011121314&lt;?php$model=Post::model();$transaction=$model-&gt;dbConnection-&gt;beginTransaction();try &#123; // 查找和保存是可能由另一个请求干预的两个步骤 // 这样我们使用一个事务以确保其一致性和完整性 $post=$model-&gt;findByPk(10); $post-&gt;title='new post title'; $post-&gt;save(); $transaction-&gt;commit();&#125; catch(Exception $e) &#123; $transaction-&gt;rollBack();&#125;?&gt; 命名范围: 即查询时的过滤器 定义 12345678910111213141516171819202122232425262728&lt;?phpclass Post extends CActiveRecord &#123; /** * 默认命名范围, 隐式应用于所有关于此模型的 SELECT 查询 */ public function defaultScope() &#123; return array( 'condition'=&gt;\"language='\".Yii::app()-&gt;language.\"'\", ); &#125; /** * 这里定义的命名范围可以被显式应用于 SELECT,UPDATE,CREATE,DELETE 操作 * @return &#123;[type]&#125; [description] */ public function scopes() &#123; return array( 'published'=&gt;array( 'condition'=&gt;'status=1', ), 'recently'=&gt;array( 'order'=&gt;'create_time DESC', 'limit'=&gt;5, ), ); &#125;&#125;?&gt; 使用 123&lt;?php$posts=Post::model()-&gt;published()-&gt;recently()-&gt;findAll();?&gt; ##关系型 Active Record 为了使用关系型 AR, 建议在关联的表中定义主键-外键约束 关系包括: BELONGS_TO, HAS_MANY, HAS_ONE, MANY_MANY, STAT 使用 STAT 关系已获取统计数据 适当使用 together 查询选项, 会加快查询速度 在 AR 查询中, 基础表的别名为 t, 其他关联表的别名和关系的名称一样 声明关系 12345678910111213141516171819202122232425262728293031323334&lt;?phpclass Post extends CActiveRecord &#123; public function relations() &#123; return array( 'author'=&gt;array(self::BELONGS_TO, 'User', 'author_id'), 'categories'=&gt;array(self::MANY_MANY, 'Category', 'tbl_post_category(post_id, category_id)'), ); &#125;&#125;class User extends CActiveRecord &#123; public function relations() &#123; return array( 'posts'=&gt;array(self::HAS_MANY, 'Post', 'author_id'), 'profile'=&gt;array(self::HAS_ONE, 'Profile', 'owner_id'), ); &#125;&#125;// 使用额外的选项// 可用选项包括: select, condition, params, on, order, with, joinType, alias, together, join, group, having, index// 当使用 `STAT` 关系时, 可用的选项包括: select, defaultValue, condition, params, order, group, havingclass User extends CActiveRecord &#123; public function relations() &#123; return array( 'posts'=&gt;array(self::HAS_MANY, 'Post', 'author_id', 'order'=&gt;'posts.create_time DESC', 'with'=&gt;'categories'), 'profile'=&gt;array(self::HAS_ONE, 'Profile', 'owner_id'), ); &#125;&#125;?&gt; 执行关联查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php// 1. 懒惰式加载: // 获取 ID 为 10 的帖子$post=Post::model()-&gt;findByPk(10);// 获取帖子的作者(author): 此处将执行一个关联查询。$author=$post-&gt;author;// 2. 渴求式加载(比懒惰式高效)// 2.1 常规方式// 获取 post 及其作者和分类$posts=Post::model()-&gt;with('author')-&gt;findAll();// 获取 post 及其作者和分类, 以及作者简介(author.profile) 和帖子(author.posts)$posts=Post::model()-&gt;with( 'author.profile', 'author.posts', 'categories')-&gt;findAll();// 2.2 指定 `CDbCeteria::with` 属性$criteria=new CDbCriteria;$criteria-&gt;with=array( 'author.profile', 'author.posts', 'categories',);$posts=Post::model()-&gt;findAll($criteria);// 2.3 配置数组$posts=Post::model()-&gt;findAll(array( 'with'=&gt;array( 'author.profile', 'author.posts', 'categories', ));// 3. 动态// 3.1User::model()-&gt;with(array( 'posts'=&gt;array('order'=&gt;'posts.create_time ASC'), 'profile',))-&gt;findAll();// 3.2$user=User::model()-&gt;findByPk(1);$posts=$user-&gt;posts(array('condition'=&gt;'status=1'));// 如果关系中没有相关的实例，则相应的属性将为 null(BELONGS_TO, HAS_ONE) 或一个空数组(HAS_MANY, MANY_MANY)?&gt; 使用命名空间 123456789101112131415&lt;?php// 1.class User extends CActiveRecord &#123; public function relations() &#123; return array( 'posts'=&gt;array(self::HAS_MANY, 'Post', 'author_id', 'with'=&gt;'comments:approved'), ); &#125;&#125;// 2.$posts=Post::model()-&gt;published()-&gt;recently()-&gt;with('comments')-&gt;findAll();// 3.$posts=Post::model()-&gt;published()-&gt;recently()-&gt;with('comments')-&gt;findAll();?&gt; ##数据库迁移 @todo #专题 ##验证 验证即核查一个人是否真实他声称的那个人(用户名, 密码); 授权即检查是否有权操作特定的资源 定义身份类: 12345678910111213141516171819202122232425262728293031323334&lt;?phpclass UserIdentity extends CUserIdentity &#123; private $_id; /** * 这是身份类的主要工作, 实现验证 */ public function authenticate() &#123; // 使用 User AR 获取数据 $record=User::model()-&gt;findByAttributes(array('username'=&gt;$this-&gt;username)); if($record===null) &#123; $this-&gt;errorCode=self::ERROR_USERNAME_INVALID; &#125; else if &#123; ($record-&gt;password!==md5($this-&gt;password)) $this-&gt;errorCode=self::ERROR_PASSWORD_INVALID; &#125; else &#123; $this-&gt;_id=$record-&gt;id; // 使用 setState 把 title 信息存储为状态传递给 CWebUser // 之后便可以使用 Yii::app()-&gt;user-&gt;title 访问 // CWebUser 默认会存储状态信息到 session, 但如果 CWebUser::allowAutoLogin 为 true, 则会存到 cookie, 切勿将敏感信息存入 cookie $this-&gt;setState('title', $record-&gt;title); $this-&gt;errorCode=self::ERROR_NONE; &#125; return !$this-&gt;errorCode; &#125; /** * 重写 getId, 默认的实现是直接返回用户名 */ public function getId() &#123; return $this-&gt;_id; &#125;&#125;?&gt; 登录和注销: 1234567891011121314151617181920&lt;?php// 1. 使用提供的用户名和密码登录用户$identity=new UserIdentity($username,$password);if($identity-&gt;authenticate()) &#123; // 将用户身份信息存入持久存储(默认为 Session) // 之后便可以用 `Yii::app-&gt;user-&gt;isGuest` 判断用户是否登录 Yii::app()-&gt;user-&gt;login($identity);&#125; else &#123; echo $identity-&gt;errorMessage;&#125;......// 注销当前用户Yii::app()-&gt;user-&gt;logout();// 2. 使用 Cookie 登录// 要确保用户部件的allowAutoLogin被设置为true。// 保留用户登陆状态时间7天Yii::app()-&gt;user-&gt;login($identity,3600*24*7);?&gt; 如果使用 cookie 登录, 要确保不要保存敏感信息到 State, 而是保存到持久存储(数据库) 上, 最好(参见安全): 当用户成功登录时, 保存同一个随机串到 cookie State 和数据库 在之后的的自动 cookie 登录时, 对比 cookie 中和数据库中的随机串是否一致 如果用户通过登录表单登录, 刷新这个随机串 ##授权 访问控制过滤器的定义参见过滤器 过滤器定义之后, 还要通过重载 CController::accessRules 指定具体授权规则 123456789101112131415161718192021222324252627282930&lt;?phpclass PostController extends CController &#123; /** * 配置数组的值可为 * 第一项: `deny` 或者 `allow` * actions: action 名字 * users: *: 任何用户, ?: 匿名用户, @: 验证通过的用户 */ public function accessRules() &#123; return array( array('deny', 'actions'=&gt;array('create', 'edit'), 'users'=&gt;array('?'), ), array('allow', 'actions'=&gt;array('delete'), 'roles'=&gt;array('admin'), ), array('deny', 'actions'=&gt;array('delete'), 'users'=&gt;array('*'), ), // 为了确保某类动作在没允许情况下不被执行 array('deny', 'action'=&gt;'delete', ) ); &#125;&#125;?&gt; 如果授权失败 已经配置 CWebUser::loingUrl, 则重定向到此 URL, 可以这样配置: 1234567891011&lt;?phparray( ...... 'components'=&gt;array( 'user'=&gt;array( // 这实际上是默认值 'loginUrl'=&gt;array('site/login'), ), ),)?&gt; 否则显示一个 401 HTTP 例外 如果希望在用户登录成功后转到之前页面: 123&lt;?phpYii::app()-&gt;request-&gt;redirect(Yii::app()-&gt;user-&gt;returnUrl);?&gt; ##基于角色的访问控制(Role-Based Access Control) 授权项目可分为操作(operations), 任务(tasks) 和角色(roles) 一个角色由若干任务组成, 一个任务由若干操作组成， 而一个操作就是一个许可, 不可再分. Yii 还允许一个角色包含其他角色或操作, 一个任务可以包含其他操作, 一个操作可以包括其他操作. 授权项目是通过它的名字唯一识别的 一个授权项目可能与一个业务规则关联. 业务规则是一段 PHP 代码, 在进行涉及授权项目的访问检查时将会被执行. 仅在执行返回 true 时, 用户才会被视为拥有此授权项目所代表的权限许可 Yii 提供了两种授权管理器： CPhpAuthManager 和 CDbAuthManager. 前者将授权数据存储在一个 PHP 脚本文件中而后者存储在数据库中. 配置 CWebApplication::authManager 应用组件时, 我们需要指定使用哪个授权管理器组件类, 以及所选授权管理器组件的初始化属性值: 1234567891011121314&lt;?phpreturn array( 'components'=&gt;array( 'db'=&gt;array( 'class'=&gt;'CDbConnection', 'connectionString'=&gt;'sqlite:path/to/file.db', ), 'authManager'=&gt;array( 'class'=&gt;'CDbAuthManager', 'connectionID'=&gt;'db', ), ),);?&gt; 然后, 我们便可以使用 Yii::app()-&gt;authManager 访问 定义授权等级体总共分三步 定义授权项目 CAuthManager::createRole CAuthManager::createTask CAuthManager::createOperation 建立授权项目之间的关系 CAuthManager::addItemChild CAuthManager::removeItemChild CAuthItem::addChild CAuthItem::removeChild 分配角色给用户 CAuthManager::assign CAuthManager::revoke 如: 1234567891011121314151617181920212223242526272829303132333435&lt;?php// 并不需要在每个请求中都要运行$auth=Yii::app()-&gt;authManager;$auth-&gt;createOperation('createPost','create a post');$auth-&gt;createOperation('readPost','read a post');$auth-&gt;createOperation('updatePost','update a post');$auth-&gt;createOperation('deletePost','delete a post');$bizRule='return Yii::app()-&gt;user-&gt;id==$params[\"post\"]-&gt;authID;';$task=$auth-&gt;createTask('updateOwnPost','update a post by author himself',$bizRule);$task-&gt;addChild('updatePost');$role=$auth-&gt;createRole('reader');$role-&gt;addChild('readPost');$role=$auth-&gt;createRole('author');$role-&gt;addChild('reader');$role-&gt;addChild('createPost');$role-&gt;addChild('updateOwnPost');$role=$auth-&gt;createRole('editor');$role-&gt;addChild('reader');$role-&gt;addChild('updatePost');$role=$auth-&gt;createRole('admin');$role-&gt;addChild('editor');$role-&gt;addChild('author');$role-&gt;addChild('deletePost');$auth-&gt;assign('reader','readerA');$auth-&gt;assign('author','authorB');$auth-&gt;assign('editor','editorC');$auth-&gt;assign('admin','adminD');?&gt; 权限检查: 1234567891011&lt;?phpif(Yii::app()-&gt;user-&gt;checkAccess('createPost')) &#123; // 创建帖子&#125;// 也可传参$params=array('post'=&gt;$post);if(Yii::app()-&gt;user-&gt;checkAccess('updateOwnPost',$params)) &#123; // 更新帖子&#125;?&gt; 默认角色就是一个隐式分配给每个用户的角色, 这些用户包括通过身份验证的用户和游客 配置: 12345678910&lt;?phpreturn array( 'components'=&gt;array( 'authManager'=&gt;array( 'class'=&gt;'CDbAuthManager', 'defaultRoles'=&gt;array('authenticated', 'guest'), ), ),);?&gt; 定义: 1234567&lt;?php$bizRule='return !Yii::app()-&gt;user-&gt;isGuest;';$auth-&gt;createRole('authenticated', 'authenticated user', $bizRule);$bizRule='return Yii::app()-&gt;user-&gt;isGuest;';$auth-&gt;createRole('guest', 'guest user', $bizRule);?&gt; ##安全 XSS: 跨站脚本攻击 定义: 攻击者常常向易受攻击的 web 应用注入 JavaScript, VBScript, ActiveX, HTML 或 Flash 来迷惑访问者以收集访问者的信息 防范: 在显示用户输入的内容之前进行检查 1234// 这里将 CHtmlPurifier 作为一个 Widget 来过滤用户输入&lt;?php $this-&gt;beginWidget('CHtmlPurifier'); ?&gt;//...这里显示用户输入的内容...&lt;?php $this-&gt;endWidget(); ?&gt; CSRF: 跨站请求伪造 定义: 攻击者在用户浏览器在访问恶意网站的时候, 让用户的浏览器向一个受信任的网站发起攻击者指定的请求 防范: GET 请求只允许检索数据而不能修改服务器上的任何数据, 而 POST 请求应当含有一些可以被服务器识别的随机数值, 用来保证表单数据的来源和运行结果发送的去向是相同的 1234567891011&lt;?php// 启用 CsrfValidation 组件// 该组件会自动在用 CHtml::form 生成的表单中嵌入一个保存随机值的隐藏项, 在表单提交的时候发送到服务器进行验证return array( 'components'=&gt;array( 'request'=&gt;array( 'enableCsrfValidation'=&gt;true, ), ),);?&gt; Cookie 攻击 定义: session ID 通常存储在 Cookie中, 如果攻击者窃取到了一个有效的 session ID, 他就可以使用这个 session ID 对应的 session 信息 防范: 您可以使用 SSL 来产生一个安全通道, 且只通过 HTTPS 连接来传送验证 cookie 设置 cookie 的过期时间, 对所有的 cookie 和 session 令牌也这样做 防范跨站代码攻击, 因为它可以在用户的浏览器触发任意代码, 这些代码可能会泄露用户的 cookie 在 cookie 有变动的时候验证 cookie 的内容 12345678910111213141516171819&lt;?php// 1. 启用 CookieValidation 组件 return array( 'components'=&gt;array( 'request'=&gt;array( 'enableCookieValidation'=&gt;true, ), ),);// 然后只使用 CHttpRequest::cookies 进行 cookie 操作(而不是 $_COOKIES)// 检索一个名为$name的cookie值$cookie=Yii::app()-&gt;request-&gt;cookies[$name];$value=$cookie-&gt;value;......// 设置一个cookie$cookie=new CHttpCookie($name,$value);Yii::app()-&gt;request-&gt;cookies[$name]=$cookie;?&gt;","categories":[{"name":"notes","slug":"notes","permalink":"https://fantasylion.github.io/categories/notes/"}],"tags":[{"name":"php","slug":"php","permalink":"https://fantasylion.github.io/tags/php/"},{"name":"framework","slug":"framework","permalink":"https://fantasylion.github.io/tags/framework/"}]},{"title":"理解 diff 命令","slug":"2015-09-28-Understanding_the_diff_command_in_unix","date":"2015-09-27T16:00:00.000Z","updated":"2015-09-27T16:00:00.000Z","comments":true,"path":"translation/2015-09-28-Understanding_the_diff_command_in_unix/","link":"","permalink":"https://fantasylion.github.io/translation/2015-09-28-Understanding_the_diff_command_in_unix/","excerpt":"Unix 系统管理员来经常需要去知道两个文件之间有什么差异. diff 命令就是干这个的. 我现在就准备讲讲 diff. 它是一个经常被用到却不是很被了解的命令. 我希望 Unix 使用者在读完这篇文章之后能够正确了解这个命令的用途并从中获益.","text":"原文在 2009/04/17 发表于 http://unix.worldiswelcome.com/understanding-the-diff-command-in-unix Unix 系统管理员来经常需要去知道两个文件之间有什么差异. diff 命令就是干这个的. 我现在就准备讲讲 diff. 它是一个经常被用到却不是很被了解的命令. 我希望 Unix 使用者在读完这篇文章之后能够正确了解这个命令的用途并从中获益. 另外一个有用的命令是: comm 命令. 我们开始吧… 示例文件分别是 first 文件和 second 文件. 如下: 1234567891011121314wiw_labs:$ nl first1 computer2 modem3 monitor4 phone5 switchwiw_labs:$ nl second1 cable2 mobile3 screen4 modem5 phone6 server diff 命令用来比较这两个文件之间的差异 #diff 命令的用法 我命先从 diff 的用法说起. diff 通常这样使用: diff first_file second_file 这条命令意即: first_file 和 second_file 有什么不同 #diff 命令如何工作 diff 命令的运作原理就是, 想法设法的让 first 文件和 second 文件一样. 它希望通过更改©, 删除(d) first 文件中的行以使其和 second 文件一模一样. 如果需要, 它还会把 second 文件中的行附加到 first 文件中. 如果你明白我说的什么, 很好, 如果不明白也随便. 当我使用示例给你解释的时候你就会明白的. diff 就是通过下面的这些步骤来生成这两个文件的差异报告的: 它从 first 文件和 second 文件的第 1 行开始. 如果它们不一样, diff 便顺着 first 文件往下找, 直到找到和 second 文件中相似的条目. 如果在 first 文件中没有找到和 second 文件第 1 行相同的行, 它就再从 second 文件的第 2 行开始. 它会在 first 文件中开始找. 然后提议做什么(附加, 更改或删除) #示例 理论讲得够多了. 我们来点实际例子好解释的更通透一点. 我把这两个文件并排来放, 好理解起来更容易一些. 另外行号也一并显示了出来. 123456789101112131415161718192021wiw_labs:$ paste first second|nl1 computer cable2 modem mobile3 monitor screen4 phone modem5 switch phone6 serverwiw_labs:$ diff first second1c1,3&lt; computer—&gt; cable&gt; mobile&gt; screen3d4&lt; monitor5c6&lt; switch—&gt; server 现在, 看一下上面 paste 命令带行号的输出. 注意下面几点: first 文件的第 2 行(modem) 和 second 文件的第 4 行(modem) 一致. 所以, 如果我们把 first 文件中的第 1 行换成 second 文件中的 1 到 3 行, 这两个文件的第一部分便都一样了. 输出看起来就会是这样的: 12345678wiw_labs:$ paste first second|nl1 cable cable2 mobile mobile3 screen screen4 modem modem5 monitor phone6 phone server7 switch first 文件的第 4 行(phone) 和 second 文件的第 5 行一致. 这意味着如果我们删除 first 文件中的第 3 行(也就是目前的第 4 行), 这两个文件的第二部分便都一样了. 1234567wiw_labs:$ paste first second|nl1 cable cable2 mobile mobile3 screen screen4 modem modem5 phone phone6 switch server first 文件的第 5 行(switch)可用 second 文件的第 6 行(server)替换. 至此, 这两个文件完全一样了. 1234567wiw_labs:$ paste first second|nl1 cable cable2 mobile mobile3 screen screen4 modem modem5 phone phone6 server server 现在, diff 命令的输出更容易理解了: 1c1,3: 更改 first 文件的第一行为 second 文件的 1 到 3 行 3d4: 从 first 文件中删除第 3 行(modem). 5c6: 更改 first 文件中的第 5 行(switch) 为 second 文件中的第 6 行(server) 现在, 反过来再看一下: 123456789101112131415161718192021wiw_labs:$ paste second first | nl1 cable computer2 mobile modem3 screen monitor4 modem phone5 phone switch6 serverwiw_labs:$ diff second first1,3c1&lt; cable&lt; mobile&lt; screen—&gt; computer4a3&gt; monitor6c5&lt; server—&gt; switch 我们看到 first 文件的第 4 行(modem) 和 second 文件的第 2 行一致. 所以如果我们把 first 文件的 1 到 3 行替换为 second 文件的第 1 行, 我们得到如下输出: 123456wiw_labs:$ paste second first | nl1 computer computer2 modem modem3 phone monitor4 server phone5 switch 现在, second 文件的第 3 行(monitor) 在 first 文件中并不存在. 所以, 把它附加到 first 文件的第 4 行(modem)后面. 要记住 diff 命令的输出中的行号永远指的是原始的行号. 现在, 输出看起来是这样的: 123456wiw_labs:$ paste second first | nl1 computer computer2 modem modem3 monitor monitor4 phone phone5 server switch first 文件的第 6 行(server)需要改成 second 文件的第 5 行(switch). 更改之后, 两个文件便都一样了: 123451 computer computer2 modem modem3 monitor monitor4 phone phone5 switch switch 现在, 更容易理解 diff 命令的输出了: 1,3c1: 把 first 文件的第 1 到 3 行改为 second 文件的第 1 行. 4a3: 在 first 文件的第 4 行(modem)后面附加上 second 文件的第 3 行(monitor). 6c5: 把 first 文件的第 6 行(server)改为 second 文件的第 5 行(switch).","categories":[{"name":"translation","slug":"translation","permalink":"https://fantasylion.github.io/categories/translation/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://fantasylion.github.io/tags/linux/"}]},{"title":"HTTP 头和 PHP header() 函数","slug":"2015-09-26-Http_headers_and_PHP_header()_function","date":"2015-09-25T16:00:00.000Z","updated":"2015-09-25T16:00:00.000Z","comments":true,"path":"translation/2015-09-26-Http_headers_and_PHP_header()_function/","link":"","permalink":"https://fantasylion.github.io/translation/2015-09-26-Http_headers_and_PHP_header()_function/","excerpt":"许多初级到中级的的 PHP 程序员把 header() 函数当作某种神秘巫术. 他们可以照着代码示例把功能实现, 但是还是不知道到底它是如果运作的. 我最开始就是这样的. 实际上它非常简单. 在这篇文章中, 我会解释 HTTP 头(header) 是如何运作的, 它们与 PHP 的关系, 以及它们的 meta 标签 equivalents(对应物)","text":"原文链接: http://www.nicholassolutions.com/tutorials/php/headers.html 版权: 本文受 Creative Commons License 版权保护, 你可以在 Creative Commons Attribution NonCommercial NoDerives 2.5 License 下分发该文 引言 许多初级到中级的的 PHP 程序员把 header() 函数当作某种神秘巫术. 他们可以照着代码示例把功能实现, 但是还是不知道到底它是如果运作的. 我最开始就是这样的. 实际上它非常简单. 在这篇文章中, 我会解释 HTTP 头(header) 是如何运作的, 它们与 PHP 的关系, 以及它们的 meta 标签 equivalents(对应物) 希望你读完之后, 能更顺手的使用 header() 函数, 甚至想出一些更多利用它的地方. 我们也会讲到其他一些关于 HTTP 和 PHP 的重要话题. 但是在我们开始讲任何程序相关的东西之前, 我们需要先快速(并且不完整的)过一遍 HTTP (HyperTex Transfer Protocol) 运作原理 HTTP 概览 Headers: 对话中的词语 HTTP 是 web 服务器和客户端浏览器之间的数据传输(比如 web 页面中的 HTML, 图片, 文件)协议('规则’集合), 并且通常使用 80 端口. 这就是网站 URL 前面 ‘http://’ 的来源 很多人最开始制作 web 页面的时候, 他们先在本地电脑上写 HTML, 在本地浏览器查看是否符合预期, 然后上传到服务器, 就可以在网上浏览这些页面了. 看起来好像在无论在本地查看与在服务器上查看的页面都一样, 传输的数据只有这些 HTML 以及它包含的图片. 但是实际上还有另外一些许多你没看到的信息 - 头信息. 头信息可以分为两大类: 你浏览器向服务器请求文件时发出的请求头信息, 服务器提供文件给浏览器时发出的响应头信息. 把这些头信息当作浏览器和服务器对话时的词语. 我喜欢把服务器想象为图书管理员, 把浏览器想象成正在请求图书资源的学者. 浏览器走向位于服务台 (80 端口) 的服务器, 说道, “Hi, 我是 Mozilla, 我正在找这个编目号是 ‘www.expertsrt.com’ 的资源. 你可以帮我找到它吗?” 服务器听到后回应 “是的, 我找到了, 让我把它给你. 这里面是 HTML 文本, 它写的是 ‘&lt;html&gt;...’” 浏览器开始从头到尾的读它, 并且遇到了一个图片标签, 所以向服务器要位于 src 属性指定处的图片. 服务器进行查找, 找到这个文件然后说道 “这是个 PNG 图片, 它的数据是…” 你懂的. 另一个对话可能像这样: 浏览器: Hi, 我是 Mozilla, 能给我在 ‘www.expertsrt.com/moved.html’ 这里的文件吗?. 服务器: 那个文件已经不在那儿了, 他现在在 ‘www.expertsrt.com/newloc.html’. 浏览器: Hi, 我是 Mozilla, 能给我在 ‘www.expertsrt.com/newloc.html’ 这里的文件吗? 服务器: 我找到这个文件了. 查看它 10 秒钟然后再向我问一次. 它是一个 HTML 文本文件, 它有这些内容… …10 秒钟… 浏览器: Hi, 我是 Mozilla, 能给我在 ‘www.expertsrt.com/newloc.html’ 这里的文件吗? 服务器: 我找到这个文件了. 查看它 10 秒钟然后再向我问一次. 它是一个 HTML 文本文件, 它有这些内容… …10 秒钟… 浏览器: Hi, 我是 Mozilla, 能给我在 ‘www.expertsrt.com/newloc.html’ 这里的文件吗? 服务器: 我找到这个文件了. 查看它 10 秒钟然后再向我问一次. 它一个 HTML 文本文件, 它有这些内容… …诸如这般, 直到浏览器被用户重新定向… 正如你所看到的, 使用头信息可以控制许多事情. 使用 header() 函数, 你可以让服务器发送你所需的头信息, 这样你可以做除了发送 HTML 之外许多很酷的事情. 看看整个对话过程 在继续之前, 让我们先不使用浏览器来查看一个 web 页面, 这样我们可以看到整个对话, 更好的了解 HTTP 头的工作. 先打开命令行 (在 windows 中, 点击开始菜单-&gt;运行, 输入 cmd, 然后点击 “OK”…如果你正使用 linux, 你或许已经知道怎么打开了). 在命令行中输入: telnet expertsrt.com 80 然后回车. 这会链接到 expersrt.com 的 80 端口. 然后, 复制并粘贴下面的文字: GET / HTTP/1.1 Host: expertsrt.com 如果你输入或粘贴这些文字的时候, 命令行除了光标的闪烁没看到任何动静的话, 不要担心 – 它们确实被发送到服务器了. 第一行说明你使用 GET 请求方法去获取资源 / (这里是目标主机上基目录里的文件), 并且你在使用 HTTP 1.1 版本. 第二行告诉服务器你想要连接到哪台主机. 当你输入 ‘expertsrt.com’ 后, 回车两次 (只需两次). 你应当立刻得到类似下面的响应: HTTP/1.1 301 Moved Permanently Date: Wed, 08 Feb 2006 07:44:07 GMT Server: Apache/2.0.54 (Debian GNU/Linux) mod_auth_pgsql/2.0.2b1 mod_ssl/2.0.54 OpenSSL/0.9.7e Location: http://www.expertsrt.com/ Content-Length: 233 Content-Type: text/html; charset=iso-8859-1 &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt; &lt;html&gt;&lt;head&gt; &lt;title&gt;301 Moved Permanently&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;h1&gt;Moved Permanently&lt;/h1&gt; &lt;p&gt;The document has moved &lt;a href=&quot;http://www.expertsrt.com/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 哎呀! 看起来好像我们请求的文件已经不在那儿了; 它已经被移到新的地方了: http://www.expertsrt.com. 如果你使用浏览器, 你只会看到 HTML - 在第一个空白行之前的都是头信息. 实际上, 现代浏览器比这更智能 - 当他们看到第三行的新的 URL 时, 会自动转向那里, 这样你就不用手动再输入这个新的 URL 了. 让我们去这个新的 URL. 这时可能你已经断开连接了. 如果这样, 只需按向上键, telnet 命令会出现, 然后回车以重新连接. 如果你没有断开连接, 那直接输入下面的文字就行: GET / HTTP/1.1 Host: www.expertsrt.com 然后回车两次. 你会看到另一个类似的响应, 告诉你那个页面实际上在 http://www.expertsrt.com/index.php. 服务器真挑剔是不是? 😉 重复上面的操作, 不过这次输入 GET /index.php HTTP/1.1 Host: www.expertsrt.com 注意我们想要的文件名在第一行. 这一次我们屏幕被文字刷满了: 这就是来自 ERT 主页的 HTML. 这里的头信息看起来是这样的 HTTP/1.1 200 OK Date: Wed, 08 Feb 2006 08:20:07 GMT Server: Apache/2.0.54 (Debian GNU/Linux) mod_auth_pgsql/2.0.2b1 mod_ssl/2.0.54 OpenSSL/0.9.7e X-Powered-By: PHP/4.4.0 Transfer-Encoding: chunked Content-Type: text/html 很简单是不是? 我们来继续探讨这跟你编程有什么关系. 如果你不明白我们讲到的所有事情也没有关系. 重要的是对浏览器和服务器如何交互的有个大致印象, 以及意识到并没有什么魔法在里面. 最终就是这些 浏览器和服务器通过使用头信息来进行交互 头信息在主要内容之前发送, 并且用两个 CRLF/换行符 来和主要内容分割开 在头信息部分, 每一行就是一个头. 首先是头的名字, 然后是一个冒号一个空格, 然后是这个头的名/值 头名: 头值 头信息可以包括许多类型的信息和指示, 以便浏览器和服务器用来告知对方接下来该做什么 提示: 如果你是那种刨根问底的人, 你可以看看 RFC 2616, 那是 HTTP/1.1 的完整规范. 尤其是 14 章, 包含每一个头的完整定义 PHP header(): 基础 注意在我们最终得到的主页中的 X-Powered-By: PHP/4.4.0 和 Content-Type: text/html 这两个头信息. PHP 一开始就被设计成输出 HTML ( PHP 中的 H 即代表 ‘Hypertext’), 并且在 PHP 脚本第一次生成输出(比如, 使用 echo)时, 会自动为你包含这些头信息. 这非常方便, 但也造成许多 PHP 新手对头信息的困惑 - 在像 Perl 这样不是一开始就被设计成用于 web 开发的语言中, 不包含你自己的头而直接发送输出会产生 ‘500 Internal Server Error’ 错误, 所以 Perl 的 web 开发者不得不立即学习关于头信息的知识 header() 函数发送 HTTP 响应头信息, 而且只做这件事 使用这个函数, 你可以让你的脚本发送你选择的头信息给浏览器, 创造一个非常有用的动态结果. 但是, 你需要知道关于 header() 函数的第一件事就是你必须在 PHP 发送任何输出(这会使 PHP 自动发送默认的头信息)之前使用它 我怀疑有哪个 PHP 程序员没有见到过如下的错误消息 Warning: Cannot modify header information - headers already sent by..... 如我们所说的, 响应头信息用一个空白行和主要内容分割. 这意味你仅可以发送头信息一次, 如果你的脚本有任何输出 (即使一个在 &lt;?php 标签之前的空白行或空格), PHP 就会自动发送头信息. 例如, 看一下下面这个脚本, 看起来逻辑上很正常: 123456789Welcome to my website!&lt;br /&gt;&lt;?php if($test)&#123; echo \"You're in!\"; &#125; else&#123; header('Location: http://www.mysite.com/someotherpage.php'); &#125;?&gt; 这个脚本判断 $test 是否为 true, 如果不是则使用 Location 头重定向访问者. 看到问题所在了吗? ‘Welcome…’ 文字始终会发送出去, 所以默认的头信息会自动被发送. 在调用 header() 时已经太晚了: 用户只看到一条错误消息 (如果你把错误报告关掉了, 则只会看到 ‘Welcome…’ 文字), 而不是被重定向 基本上有两种解决方法. 第一个就是重写代码 12345678&lt;?php if($test)&#123; echo 'Welcome to my website&lt;br /&gt;You're in!'; &#125; else&#123; header('Location: http://www.mysite.com/someotherpage.php'); &#125;?&gt; 第二个就是使用输出缓冲, 这个解决方法更为优雅易用. 在我们上面的例子中, 重写代码并不困难, 但是试想一下如果有很多 HTML 需要移动位置 - 这样做就会很麻烦, 也会让我们的代码更难追踪. 虽然我们第一个示例导致了错误, 但是逻辑上是没错的. 输出缓冲可以让你一直保留(‘缓冲’)输出(即使是 PHP 代码之外的 HTML)直到你明确指示了把输出发送给浏览器. 这样你就可以随意编写你的代码, 知道你指定了你需要指定的头信息, 然后明确指示发送这些输出. 两个相关的函数是 ob_start() 和 ob_flush(), ob_start()用于打开输出缓冲, ob_flush() 会发送缓冲了的输出: 1234567891011121314&lt;?php ob_start(); //开始输出缓冲?&gt;Welcome to my website!&lt;?php if(true)&#123; echo \"You're in!\"; &#125; else&#123; header('Location: http://www.mysite.com/someotherpage.php'); &#125; ob_flush(); //输出缓冲中的数据?&gt; 我鼓励你读一下所有关于输出缓冲的函数, 非常有用. 你应当尽早的把输出缓冲发送出去, 尤其当你有许多东西想要发送的时候. 否则你的页面会看起来加载的很慢, 因为所有的内容只有被组装完毕后才发送, 而不是当可用的时候立即就被发送出去. 提示: 第二个参数 如果你调用 header() 不止一次发送同一个头, 这个头的值将会是_最后_调用的 header() 中设置的值. 如, 1234&lt;?phpheader('Some-Header: Value-1');header('Some-Header: Value-2');?&gt; 会产生 Some-Header: Value-2 这个结果. 你可以通过设置第二个参数来发送同一个头两次. 这个参数默认是 true. 如果你设置其为 false, 那么第二个头值不会替换第一个, 而是两个都被发送. 所以下面的代码 1234&lt;?phpheader('Some-Header: Value-1');header('Some-Header: Value-2', false); //不要替换第一个?&gt; 将会产生 Some-Header: Value-1, Value-2 这个结果. 你很少会用到这个, 但是知道它也不错. 知道了 HTTP header 和 PHP 如何配合之后, 让我们来看一些更为具体的例子. #PHP header(): 一些例子 提示: 下面这个代码片断都是截取自完整的工作代码. 当你在自己的程序中包含他们的时候, 记得定义所有你自己的变量, 赋给他们默认值, 以及遵循其他最佳实践. ##使用 Location 头重定向 我们已经在上面看到过几次了: 它会重定向浏览器. 123&lt;?phpheader('Location: http/www.mysite.com/new_location.html');?&gt; 虽然你给它一个相对 URL 没准也能工作, 但是根据 HTTP 规范, 你真的应该使用一个绝对 URL. 一个容易犯的错误就是在使用了 Location header 之后不立即使用 exit 以结束执行 (你可能不是总是想要结束执行, 但是大部分时间是的). 之所以这是一个错误是因为 PHP 代码会继续执行, 即使用户已经被重定向到新的 URL. 在最好的情况下, 这会不必要的使用系统资源. 在最坏的情况下, 你可能会执行一些让自己后悔的操作. 看一下下面的代码: 12345678910&lt;?php//重定向访问级别低于 4 的用户if (check_access_level($username) &lt; 4)&#123; header('Location: http://www.mysite.com/someotherpage.php');&#125;//向高于访问级别 4 的用户发送秘密邮件mail_secret_code($username);echo 'The secret email is on its way!';?&gt; 未授权用户的确被重定向了, 但是因为代码会继续执行, 他们同样会收到邮件. 为了避免这种情况, 针对已授权用户的代码可以写到 else{} 声明中, 但是直接在 header() 后面使用 exit 来结束代码执行会更为干净容易一些. 1234567891011&lt;?php//重定向访问级别低于 4 的用户if (check_access_level($username) &lt; 4)&#123; header('Location: http://www.mysite.com/someotherpage.php'); exit; //停止代码执行&#125;//向高于访问级别 4 的用户发送秘密邮件mail_secret_code($username);echo 'The secret email is on its way!';?&gt; 使用 Refresh 头重定向 Refresh 和 Location 一样可以重定向用户, 但是你可以延迟重定向. 例如, 下面的代码会在显示当前页面 10 秒钟后重定向用户到新的页面: 1234&lt;?phpheader('Refresh: 10; url=http://www.mysite.com/otherpage.php');echo 'You will be redirected in 10 seconds';?&gt; 另一个常见的用途就是通过重复的’重定向’一个页面到它自身来强制更新页面 (参见上面的第二个 ‘对话’). 例如, 这里是一个简单的例子, 页面会从 10 开始向下数, 每个数字之间有 3 秒间隔: 12345678910111213&lt;?phpif(!isset($_GET['n']))&#123; $_GET['n'] = 10;&#125;if($_GET['n'] &gt; 0)&#123; header('Refresh: 3; url=' . $_SERVER['PHP_SELF'].'?n=' . ($_GET['n']-1) ); echo $_GET['n'];&#125;else&#123; echo 'BLAST OFF!';&#125;?&gt; 提示: 如果刷新时间设置成 0, 则 Refresh 头实际上和 Location 头完全一样 使用 Content-Type 头来提供不同类型的文件以及生成动态内容 服务器用 Content-Type 头告诉浏览器自己将要发送什么类型的数据. 使用这个头信息, 你可以让 PHP 脚本输出任何类型的文件, 从纯文本文件到图片文件到 zip 文件等等. 下面的表格列举了最常用的一个 MIME 类型: 常用 MIME 类型: 类型 描述 text/html HTML (PHP 默认) text/plain 纯文本 image/gif GIF 图片 image/jpeg JPEG 图片 image/png PNG 图片 video/mpeg MPEG 视频 audio/wav WAV 音频 audio/mpeg MP3 音频 video/mov mov 视频 video/quicktime Quicktime 视频 video/x-ms-wmv Windows WMV 视频 audio/x-ms-wma Windows WMA 音频 audio/x-realaudio RealPlayer 音频/视频 (.rm) audio/x-pn-realaudio RealPlayer 音频/视频 (.ram) video/x-msvideo ms 视频 video/avi AVI 视频 application/pdf PDF 文档 application/msword MS Word .doc 文件 application/zip Zip 文件 application/octet-stream 其他. 数据. 用于强制下载或使用应用打开.* x-foo/x-bar 其他. 数据. 用于强制下载或使用应用打开.* 你可以用此来做一些有趣的事情. 比如, 你可能想要向用户发用一个预先格式化过的文本文件, 而不是 HTML: 1234&lt;?phpheader('Content-Type: text/plain');echo $plain_text_content;?&gt; 另或者你想要提示用户下载文件, 而不是在浏览器中查看它. 使用 Content-Disposition 头, 这很容易, 你甚至可以推荐一个文件名给用户: 123456&lt;?phpheader('Content-Type: application/octet-stream');header('Content-Disposition: attachment; ' .'filename=\"plain_text_file.txt\"');echo $plain_text_content;?&gt; 另或者你需要提供文件文件, 但是又希望隐藏文件的真实路径和名字, 并且只让已登录的用户下载: 1234567891011&lt;?phpif($b_is_logged_in)&#123; header('Content-Type: application/octet-stream'); header('Content-Disposition: attachment; ' .'filename=\"'.$different_filename.'\"'); readfile('/path/to/files/' . $filename);&#125;else&#123; echo 'You are not authorized to view this file';&#125;?&gt; 又或者你已经使用 PHP 的图片函数动态生成了一个图片, 想要展示给用户. 你可以创建一个 build_image.php 文件, 像这样 12345&lt;?php //生成图片, 然后 header('Content-Type: image/jpeg'); imagejpeg($image_resouce);?&gt; 提示: 当心 magic_quotes! PHP 会自动使用反斜杠转移特殊字符, 这一开始看起来是个好主意, 但是大多数好的程序员认为 (a) 这会鼓励不去验证输入的粗心代码, 并且 (b) 在良好的代码中会产生本不该有 (如果 magic_quote 关闭) 的麻烦. 其中一个麻烦就是二进制数据被破坏. 在上面这个例子中, 如果 magic_quotes_runtime被启用, 则 readfile() 输出的数据可能被添加反斜杠, 导致发送给用户的文件被破坏. 完美情况下, 你应该在 php.ini 文件中关闭 magic_quotes_runtime 选项, 但是如果你没有权限访问这个配置文件, 你可以使用 set_magic_quotes_runtime() 函数 (给它传个数字 0) 关闭它. 令人高兴的是, 最近的一次 PHP 开发者会议显示, 在未来版本(6+) 的 PHP 中 magic quotes 会被弃用. 但是在所有人升级到这个版本的 PHP 之前, 记住这个导致的问题会节省你很多麻烦和疑问. 你可以在 URL 中传递生成图片所需的参数, 然后使用 $_GET 获取它们. 然后在另一个页面, 你可以使用 img 标签来包含这个图片: 1&lt;img src=\"build_image.php&lt;?php echo \"?$user_id&amp;amp;$caption\"; ?&gt;\"&gt; 可用的地方几乎讲不完. 你 PHP 变成越多, 越会发现 Content-Type 头真的是你的好朋友 提示: 浏览器处理各式 MIME类型 的_预期_方式以及_实际_方式可能并不一致 (尤其是 Internet Explorer), 所以你最好是在你需要支持的浏览器中测试一下. PHP 参考中的用户评论有许多关于此的技巧. ##防止页面缓存 PHP 页面通常会生成非常动态的内容, 为了防止用户因为页面缓存而错过了更新过的页面, 告诉浏览器不要缓存特定的页面通常非常有用. 下面的代码在可能会访问你网站的浏览器中工作的很好: 12345&lt;?phpheader('Cache-Control: no-cache, no-store, must-revalidate'); //HTTP/1.1header('Expires: Sun, 01 Jul 2005 00:00:00 GMT');header('Pragma: no-cache'); //HTTP/1.0?&gt; Expires 头可以是任何已经过去的日期. 对于 MIME 类型, 浏览器 (尤其是较老的) 可能不会总是正确的理解你的缓存指示 (虽然大部分现代浏览器会). 其他应用 还有另外一个可以使用头信息的地方, 比如设置 HTTP 响应码, 或者执行 HTTP 认证 (如果你作为 Apache 模块来使用 PHP 的话). 现在, 你了解了 header() 如何工作及怎么使用它, 你可以用它做你之前想都没想到的许多事情了. PHP 中的请求头信息 我们讲了怎么使用响应头信息了. 我们还可以从浏览器发给服务器的请求头信息中获取很多信息. 有两种方法来获取. 第一, 许多 [$_SERVER数组][server]中的值都是由传来的请求头信息决定的. 第二, 如果 PHP 是作为 Apache 模块使用的, apache_request_headers() 会返回一个包含所有请求头信息的数组 (甚至那些不在 $_SERVER 中的). 安全第一: 不要信任请求头信息 因为请求头信息发自浏览器, 浏览器又可以在客户端被控制, 所以你永远不要信任来自请求头, 又和你站点安全紧密相关的头信息. 一个很好的例子就是 $_SERVER['HTTP_REFERER']变量, 这个变量应该包含一个用户转自的源 URL. 一个新手的常见错误就是认为他们可以使用这个来确保用户只会通过特定路径来访问页面, 因此他们便无需关心服务器端的数据验证. 例如, 看看下面的代码, 它试着去确保数据是从一个特定的页面发送过来的, 而不是从另一个站点 123456789&lt;?php if($_SERVER['HTTP_REFERER'] != 'http://www.mysite.com/myform.html')&#123; header('Refresh: 5; url=http://www.mysite.com/myform.html'); echo 'You must use the form on my site...redirecting now.'; &#125; else&#123; insert_data($_POST['var1'], $_POST['var2']); &#125;?&gt; 这或许会阻止那些不是很精通的黑客通过他的浏览器提交一个自定义的表单来提交数据, 但是任何一个稍微高深一些的黑客都可以通过使用 telnet 来提交数据, 包括请求头信息 Referer: http://www.mysite.com/myform.html 然后轻易的躲过这层保护机制. 这里所要讲的重点是: 使用 HTTP 请求头信息来统计一些数据以便提供更好的用户体验 - 大部分的请求头信息都是发自真实的浏览器而且可以被信任…但是不要在有关安全的问题上依赖任何请求 header 使用 HTTP 请求头信息 你可以用它做几件事. 使用 $_SERVER['HTTP_USER_AGENT']你可以探测用户生成他使用的什么浏览器. 你可以检查 $_SERVER['HTTP_ACCEPT_LANGUAGE'] (可能要配合 $_SERVER['HTTP_ACCEPT_CHARSET'] 和一些 IP 地理位置 ) 来决定向用户展示什么语言. 虽然 $_SERVER['HTTP_REFERER'] 对于安全目的并不能被依赖, 但是可以用来统计你网站的流量, 或者根据用户的访问路径来定制显示内容. 如果因为某些原因你想要操作原始的请求字符串, 你可以使用 $_SERVER['QUERY_STRING']. 查看 $_SERVER['REQUEST_METHOD'] 可以知道你的页面是通过 GET 还是 POST 方法访问的. 还有很多可以帮助你做许多有创意的事情的信息等着你去发现. #HTML meta 标签中的 HTTP 头信息 equivalents(对应物) 很有可能在阅读本文之前, 你已经用过下面的 HTML meta 标签重定向用户了: 1&lt;meta http-equiv=\"refresh\" content=\"0;http://www.mysite.com/somepage.html\" /&gt; 看起来很熟悉? ‘http-equiv’ meta 标签即 HTTP 响应头的’对应物’, 引入它们是为了让没有服务器端编程能力的人在写 HTML 页面的时候也能使用强大的头信息功能. 使用这些 meta 标签很简单: 它们可以被放在文档 &lt;head&gt; 中的任何地方, http-equiv 属性包含头名, content 属性包含头值. 我发现这些 meta 标签最开始也会和 HTTP 头一样让人困惑, 但是现在它们在你看来应该很简单了. 虽然我更喜欢使用 PHP 的 header() 函数, 但是 meta 标签的 HTTP equivalents 对于像指定字符集这样的事情会更顺手一些. 比如, 我经常在 HTML 页面中使用 (有时候 PHP 页面中也会用到): 1&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; 提示: 使用 meta 标签来指定头信息并不被一致的支持, 所以通常来讲使用头信息本身会更加安全和快速. 另外很明显, 还有一些头的名值对并不能用 meta equivalents 来指定: 在真正的头信息被发送, 浏览器已经把文档读取为 HTML 之后, 你是不能再去设置 Content-Type 成 image/png 的 😉 结语 现在我们讲完了, 你应该对 HTTP 的工作原理以及如何使用响应请求头信息以及如何把它们应用到自己的代码中有了很好的认识. 这些知识也会让你在 web 应用的效率和安全方面有更审慎的思考. 我希望在你继续编程的时候, 会发现你使用 HTTP 头信息更加顺手了, 也能通过使用它们让你的工作更加轻松, 你的页面更好了. 还有额外一点, 记住头信息就像是词语: 它们交流信息并请求某些操作被执行, 但是本身并不强制任何事情. 99.9% 的情况下, 浏览器和服务器和谐合作, 事情发展很顺利. 但记住在现实中, 是不是你会遇到一些混蛋 (黑客), 或者一些只想按照自己意愿做事的东西 (Internet Explorer). web 开发从很多角度讲是一个客服性质的工作, 所以你应该尽全力避免这些东西, 满足客户的 ‘特殊需要’ 😃","categories":[{"name":"translation","slug":"translation","permalink":"https://fantasylion.github.io/categories/translation/"}],"tags":[{"name":"php","slug":"php","permalink":"https://fantasylion.github.io/tags/php/"},{"name":"http","slug":"http","permalink":"https://fantasylion.github.io/tags/http/"}]},{"title":"java 获取图片属性","slug":"2015-07-30-java-get-color-model","date":"2015-07-29T16:00:00.000Z","updated":"2015-07-29T16:00:00.000Z","comments":true,"path":"program/2015-07-30-java-get-color-model/","link":"","permalink":"https://fantasylion.github.io/program/2015-07-30-java-get-color-model/","excerpt":"在使用AE渲染视频时，由于AE不支持某种颜色模式导致不能导入使用这个颜色模式的图片(时间有点久了忘了是那种颜色模式了-_-|||)，所以需要获取到图片使用的颜色模式，并将图片进行转码","text":"前言 在使用AE渲染视频时，由于AE不支持某种颜色模式导致不能导入使用这个颜色模式的图片(时间有点久了忘了是那种颜色模式了-_-|||)，所以需要获取到图片使用的颜色模式，并将图片进行转码 代码 1234567BufferdImage bfi = ImageIO.read( new File(\"d:/file/img.jpg\") );//获取图片位深度Int imgBit = bfi.getColorModel().getPixelSize();//获取图片颜色模式 RGB CMYK等模式bfi.getColorModel().getColorSpace().getType(); 详情请点击&gt;&gt;&gt;","categories":[{"name":"program","slug":"program","permalink":"https://fantasylion.github.io/categories/program/"}],"tags":[{"name":"java","slug":"java","permalink":"https://fantasylion.github.io/tags/java/"}]},{"title":"AE 使用","slug":"2015-07-28-AE-use-introduce","date":"2015-07-27T16:00:00.000Z","updated":"2015-07-27T16:00:00.000Z","comments":true,"path":"tool/2015-07-28-AE-use-introduce/","link":"","permalink":"https://fantasylion.github.io/tool/2015-07-28-AE-use-introduce/","excerpt":"AE全称After Effects，是由世界著名的图形设计、出版和成像软件设计公司Adobe Systems Inc.开发的专业非线性特效合成软件。是一个灵活的基于层的2D和3D后期合成软件，包含了上百种特效及预置动画效果，与同为Adobe公司出品的Premiere，Photoshop，Illustrator等软件可以无缝结合，创建无与伦比的效果","text":"AE 介绍 AE全称After Effects，是由世界著名的图形设计、出版和成像软件设计公司Adobe Systems Inc.开发的专业非线性特效合成软件。是一个灵活的基于层的2D和3D后期合成软件，包含了上百种特效及预置动画效果，与同为Adobe公司出品的Premiere，Photoshop，Illustrator等软件可以无缝结合，创建无与伦比的效果 AE简单使用 第一步: 创建project AE默认自动会创建一个 未命名的project 手动创建: 点击 File -&gt; New -&gt; New Project(快捷键: Ctrl + Alt + N) 第二步: 创建Composition(合成) 影片的所有的素材(视频, 图片, 文字…)都放在Composition中, 相当于一个容器 点击 菜单栏上的 Composition -&gt; New Composition… (快捷键 Ctrl + N) 出现如图窗口: Composition Name代表合成的名字 : 自己顺便填 Preset 代表视频格式 第三步添加素材 在空白处单击右键 import -&gt; file 选择你需要导入的图片或者视频等素材 第四步将素材添加到Composition(合成)中 方法1:将素材直接拖拽到Composition中 Eg: 如上图 将fodder文件中的素材直接拖拽到test上 即可添加成功 方法很多不列举了… 第五步制作特效 略 第六步导出影片 当素材添加到Composition成功后会出现如上图 单击左键空白部分 这个区域会显示黄色的线框 此时单击 File -&gt; Export -&gt; Add to Render Queue 在Render Queue窗口会有一个对应的render 单击lossless可以修改 影片格式等参数 单击output to 后的黄色文字可以就改保存路径和文件名 点击 右边的Render即可渲染导出影片","categories":[{"name":"tool","slug":"tool","permalink":"https://fantasylion.github.io/categories/tool/"}],"tags":[{"name":"AE","slug":"AE","permalink":"https://fantasylion.github.io/tags/AE/"}]},{"title":"CSS3(animation, trasfrom)总结","slug":"2015-05-17-css3_animation_trasfrom","date":"2015-05-16T16:00:00.000Z","updated":"2015-05-16T16:00:00.000Z","comments":true,"path":"program/2015-05-17-css3_animation_trasfrom/","link":"","permalink":"https://fantasylion.github.io/program/2015-05-17-css3_animation_trasfrom/","excerpt":"CSS3(animation, trasfrom)总结","text":"Animation 样式写法: 格式: @-浏览器内核-keyframes 样式名 {} 标准写法(chrome safari不支持 123456789@keyframes [样式名] &#123;0% &#123;left: 10px ; top : 20px;&#125;50% &#123;left: 20px ; top : 30px;&#125;100% &#123;left: 10px ; top : 20px;&#125;&#125;; Firefox 123456789@-mz-keyframes [样式名] &#123;0% &#123;left: 10px ; top : 20px;&#125;50% &#123;left: 20px ; top : 30px;&#125;100% &#123;left: 10px ; top : 20px;&#125;&#125;; Chrome &amp; Safari 123456789@-webkit-keyframes [样式名] &#123;0% &#123;left: 10px ; top : 20px;&#125;50% &#123;left: 20px ; top : 30px;&#125;100% &#123;left: 10px ; top : 20px;&#125;&#125;; Opern 123456789@-o-keyframes [样式名] &#123;0% &#123;left: 10px ; top : 20px;&#125;50% &#123;left: 20px ; top : 30px;&#125;100% &#123;left: 10px ; top : 20px;&#125;&#125;; 其他写法 1234567@keyframes [样式名] &#123;from &#123;left:0px; top:10px;&#125;to &#123;left:20px; top: 50px;&#125;&#125; 样式引用: Style=”animation:样式名 时间 播放曲线” eg: 样式 123456789101112131415 @-webkit-keyframes testRule &#123; 20% &#123;left:100px; top:50px;&#125; 40% &#123;left:50px; top: 100;&#125; 60% &#123;left:50px; top: 50;&#125; 80% &#123;left:100px; top: 0;&#125; 100% &#123;left:0px; top:0px;&#125;&#125;&#96;&#96;&#96; 元素 &lt;div style=”position:absolute;width:100px; height:100px; -webkit-animation: testRule 5s linear”&gt; &lt;/div&gt; 1说明 0s- 1s DIV从最开始位置 到 {left:100px; top:50px;} 1s -2s {left:100px; top:50px;} 到 {left:50px; top: 100;} 2s -3s {left:50px; top: 100;} 到 {left:50px; top: 50;} 3s - 4s {left:50px; top: 50;} 到 {left:100px; top: 0;} 4s - 5s {left:100px; top: 0;} 到 {left:0px; top:0px;} 12345678910111213141516171819202122232425262728293031323334353637383940 ## CSS3 Animation 所具有的属性:|name |功能 ||----------|------------||@keyframes|所有规定动画||Aniamtion |所有规定动画简写属性, 除了animation-play-state 属性||Animation-name| 规定@keyframes 动画的名称||Animation-duration| 规定动画完成一个周期所花费的秒或毫秒. 默认是 0 ||Animation-timing-function|规定动画的速度曲线.默认是 0 ||Aniamtion-delay| 规定动画从什么时候开始 默认是0||Aniamtion-iteration-count| 规定动画播放几遍 默认是1||Animation-direction| 规定动画是否在下一周期逆向地播放. 默认是 ” normal”||Animation-play-state|规定动画的当前状态 “paused” or “running” .默认是 ”running”||Animation-fill-mode|规定对象动画时间之外的状态| ps:Animation-play-state : 当在移动端使用时, 如果样式中存在trasfrom 则会不起作用(原因未知) __属性对应__|CSS3属性 | dom对象属性 | |----------|--------------------||Aniamtion | Dom.style.webkitAnimation(根据浏览器内核而定)|| | Dom.style.animation||Animation-name | Dom.style.webkitAnimationName||Animation-duration|Dom.style.webkitAnimationDuration||Animation-timing-function|Dom.style.webkitAnimationTimingFunction||Aniamtion-delay|Dom.style.webkitAnimationDelay||Aniamtion-iteration-count|Dom.style.webkitAnimationIterationCount||Animation-direction|Dom.style.webkitAnimationDirection||Animation-play-state|Dom.style.webkitAnimationPlayState||Animation-fill-mode|Dom.style.webkitAnimationFillMode|### 样式动态生成动态引入styleSheetschorome中: document.styleSheets //获取所有的样式链表文件内容 var sst = document.styleSheets[0]; //获取第0个样式链表 var str = “@keyframes name {0% {left:20px; } 100%{left:60px;}}”; sst.insertRule(str)；//将样式str 插入到 第0 个位置的样式文件中 sst.cssRules[0];//获取第0 个样式文件中第0个样式对象 123 __控制Animation播放时间__ Dom.style.webkitAnimationDelay = “-” + time + “s”; dom.display = “none”; dom.offsetHeight = “”; dom.display = “block”; # transform &lt;http://www.w3school.com.cn/cssref/pr_transform.asp&gt;","categories":[{"name":"program","slug":"program","permalink":"https://fantasylion.github.io/categories/program/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://fantasylion.github.io/tags/CSS/"}]},{"title":"GitFlow 开发模式","slug":"2015-05-06-gitflow-model","date":"2015-05-05T16:00:00.000Z","updated":"2015-05-05T16:00:00.000Z","comments":true,"path":"tool/2015-05-06-gitflow-model/","link":"","permalink":"https://fantasylion.github.io/tool/2015-05-06-gitflow-model/","excerpt":"GitFlow 开发模式","text":"翻译自：https://nvie.com/posts/a-successful-git-branching-model/ 在这篇文章中，主要介绍 Git 分支模型。不会谈论任何项目的细节，只讨论分支策略和发布管理。 Git分布式和集中式理解 我们配置了中央存储库可以很完美的配合该分支模型工作。这里需要注意下，这个仓库只是被认为 是中央仓库（因为 Git 是 DVCS （分布式版本管理系统），在技术层面上没有中央仓库）。我们将这个中央仓库称为 origin ，应该所有 Git 用户都熟悉这个名称。 每个开发人员都会从中央库 pull 并 push origin 。但除了集中式 pull push 关系之外，每个开发人员还可以从其他开发人员的库中获取更改以形成子团队。例如，在将正在开发的代码 push origin 之前，获取到其他开发人员的代码。这对于与一个大的新功能上的两个或更多开发人员一起工作可能是有用的 。在上图中，有 alice 和 bob，alice 和 david 以及 clair 和 david 的子团队。 从技术上讲，这意味着 Alice 已经定义了一个 Git 遥控器，名为 bob ，指向 Bob 的存储库，反之亦然。 主要分支 在核心，开发模型受到现有模型的极大启发。中央仓库拥有两个主要分支，具有无限的生命周期： master develop 该 master 分支在 origin 应该存在于每一个用户的 Git 。另一个与 master 并行的分支是 develop 。 我们认为 origin/master 是主要分支，这个分支 HEAD 源码始终反映生产就绪状态 ，简单来说就是 master 分支上的代码与生产使用的代码始终保持一致。这样有个好处就是，当生产代码出现紧急 bug 的时候，可以快速从 master 上 fork 出一个 hotfix 分支用来修复 bug 并发布，而不会因为修复线上 bug ，影响正在开发过程中的下一个版本的代码 我们认为 origin/develop 是主要开发分支，其 HEAD 源码始终反映了下一版本中最新交付的开发更改的状态。有些人称之为“整合分支”。这是可以用来建立夜间自动构建的分支。如果我们对此非常严格的执行，从理论上讲，我们可以使用Git钩子脚本在每次提交时自动构建和推出我们的项目到我们的测试服务器。 当 develop 分支中的源代码到达稳定点并准备好发布时，所有更改都应以某种方式合并到 master ，然后使用版本号进行标记。如何执行后面将详细讨论。 因此，每次将更改合并回 master 时，根据我们的定义，这就是一个新的生产版本。 支持分支 接下来除了两个主分支 master 和 develop ，我们的开发模型使用各种支持分支来帮助团队成员之间的并行开发，轻松跟踪功能，准备生产版本以及帮助快速修复实时生产问题。与主分支不同，这些分支的寿命有限，因为它们最终会被删除。 我们使用的不同类型的分支分别是： 功能分支 命名方式：feature-* 发布分支 命名方式：release-* 修补bug分支 命名方式：hotfix-* 这些分支中每一个都有特定的目的，并且有着严格的规则：从哪些分支中 fork 出来，又合并到那些分支中。 分支类型根据我们如何使用它们进行分类。 功能分支 分支出自： develop 必须合并回： develop 分支命名约定： 最好是 feature-[功能名]，当然如果是想自己定义其他名字只要不是 master, develop, release-, or hotfix- 就都可以 功能分支主要用于为下一个版本开发新功能。在开始开发功能时，此功能的发布版本可能在此处未知。功能分支的本质是，只要功能处于开发阶段，它就会存在，但最终会合并回 develop （以便将新功能添加到即将发布的版本中）或丢弃（在产品经理放弃这个功能的时候）。 功能分支通常仅存在于开发人员本地存储库中，而不存在于 origin 。 创建功能分支 在开始处理新功能时，从 develop 分支分支。 12$ git checkout -b myfeature developSwitched to a new branch \"myfeature\" 在开发中加入完成的功能 完成的功能分支会合并到 develop 分支中，以确保将它们添加到即将发布的版本中： 12345678$ git checkout developSwitched to branch 'develop'$ git merge --no-ff myfeatureUpdating ea1b82a..05e9557(Summary of changes)$ git branch -d myfeatureDeleted branch myfeature (was 05e9557).$ git push origin develop 该 --no-ff 参数使合并始终创建新的 commit ，最新版中 git merge 默认的就是 --no-ff 。这样可以避免丢失功能分支的历史信息，并将所有添加功能的 commit 组合到一个 commit 中。对比： 在后一种情况下，不可能从 Git 历史中看到哪些 commit 实现了一个功能 - 您必须手动读取所有日志消息。恢复整个功能（即一组提交）在后一种情况下也是比较头痛的，而如果使用该 --no-ff 标志则很容易完成 。 虽然它会创建一些（空的）commit ，但增益远远大于成本。 发布分支 分支出自：develop 必须合并回：develop 和 master 分支命名约定：release-[版本号] 发布分支主要用来发布新的版本到生产。它可以用来修复最后一分钟的 bug ，当在发布的过程中发现了新的 bug ，可以直接在 release 分支中修改。develop 分支将接收下一个大版本的功能。 需要注意的是在 develop 上创建一个新的发布分支的时候， develop 分支的代码应该是测试完毕后准备发布的代码，至少下一个版本所有的功能都已经合并到 develop 分支 。 当新建了发布分支分配新的版本号，从这个时候开始 develop 分支反映的将应该是下一个版本的代码。比如新建了release-1.6 后 1.6 版本的代码将不再允许提交到 develop 分支中。 创建发布分支 发布分支是从 develop 分支创建的。例如，假设版本 1.1.5 是当前的生产版本，我们即将推出一个大版本。状态 develop 为“下一个版本”做好了准备，我们已经决定这将版本 1.2（而不是 1.1.6或2.0 ）。 因此，我们分支并为发布分支提供反映新版本号的名称： 1234567$ git checkout -b release-1.2 developSwitched to a new branch \"release-1.2\"$ ./bump-version.sh 1.2Files modified successfully, version bumped to 1.2.$ git commit -a -m \"Bumped version number to 1.2\"[release-1.2 74d9424] Bumped version number to 1.21 files changed, 1 insertions(+), 1 deletions(-) 创建新分支并切换到它后，我们会更新版本号。这 bump-version.sh 是一个虚构的shell脚本，它可以更改工作副本中的某些文件以反映新版本。（这当然可以是手动更改 - 关键是某些文件会发生变化。）然后提交了最新的版本号。 这个新分支可能存在一段时间，直到新版发布。在此期间，可以在此分支中修复 bug（而不是在 develop 分支上）。严禁在此处添加大型新功能，新功能必须合并到 develop 等待下一个大版本。 完成发布分支 当 release 分支准备好真正发布的时候，需要执行一些操作。首先，release 分支合并到 master（因为每次提交master都是按照定义的新版本）。接下来，master必须标记 (tag) 该提交，以便将来参考此历史版本。最后，需要将发布分支上的更改合并回来 develop ，以便将来的版本也包含这些错误修复。 Git 中的前两个步骤： 123456$ git checkout masterSwitched to branch 'master'$ git merge --no-ff release-1.2Merge made by recursive.(Summary of changes)$ git tag -a 1.2 该版本现已完成，并标记以供将来参考。 编辑：您可以使用 -s 或 -u 标记以加密方式对您的标记进行签名。 为了保持 release 分支中所做的更改，我们需要将这些更改合并到 develop。在 Git 中： 12345$ git checkout developSwitched to branch 'develop'$ git merge --no-ff release-1.2Merge made by recursive.(Summary of changes) 这一步很可能导致合并冲突（可能是因为我们已经更改了版本号）。如果是出现这种情况，请修复并提交。 现在我们已经完成了，这个时候我们可以删除发布分支，因为我们不再需要它了： 12$ git branch -d release-1.2Deleted branch release-1.2 (was ff452fe). 修补程序分支 分支出自：master 必须合并回：develop 和 master 分支命名约定：hotfix-* hotfix 分支主要用来修复生产的紧急 bug ，比如当开发人员正在 feature、develop 分支 开发下一个版本的功能，而生产出现了紧急 bug 必须立刻修复并发布。而你又不想把当前未完成的版本发布到生产，这个时候我们可以在 master 分支上 fork 一个新的 hotfix 分支用来修复bug ，这样的话就不会影响到下一个版本的开发。 创建修补 Bug 分支 从 master 分支创建修复 bug 分支。例如，假设版本 1.2 是当前生产版本正在运行并且由于严重错误而影响生产正常使用。但是 develop 分支代码仍然不稳定。然后我们可以 fork hotfix 分支并开始修复问题： 1234567$ git checkout -b hotfix-1.2.1 masterSwitched to a new branch \"hotfix-1.2.1\"$ ./bump-version.sh 1.2.1Files modified successfully, version bumped to 1.2.1.$ git commit -a -m \"Bumped version number to 1.2.1\"[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.11 files changed, 1 insertions(+), 1 deletions(-) 新建分支后不要忘记标记小版本号！然后修复 bug 并提交一个或多个单独 commit。 123$ git commit -m \"Fixed severe production problem\"[hotfix-1.2.1 abbe5d6] Fixed severe production problem5 files changed, 32 insertions(+), 17 deletions(-) 完成修补 Bug 分支 完成后，需要将 hotfix 分支合并回 master，同时也需要合并回 develop ，以保证修复bug的代码也包含在下一个版本中。这与发布分支的完成方式相似。 首先，更新 master 并标记版本。 123456$ git checkout masterSwitched to branch 'master'$ git merge --no-ff hotfix-1.2.1Merge made by recursive.(Summary of changes)$ git tag -a 1.2.1 编辑：您还可以使用 -s 或 -u 标记以加密方式对您的标记进行签名。 接下来，合并 hotfix 到 develop： 12345$ git checkout developSwitched to branch 'develop'$ git merge --no-ff hotfix-1.2.1Merge made by recursive.(Summary of changes) 此处有一个例外就是， 在当前 release 分支存在时，只需要将 hotfix 分支合并到该 release 分支中即可，而不是 develop 。将 hotfix 分支合并到 release 分支中，修复的代码最终也会在 release 分支完成时被合并到 develop。（当然如果 develop 立刻需要此修复 bug 代码，不能等到 release 分支完成，您也可以直接地将 hotfix 合并到 develop。） 最后，删除这个临时分支： 12$ git branch -d hotfix-1.2.1Deleted branch hotfix-1.2.1 (was abbe5d6).","categories":[{"name":"tool","slug":"tool","permalink":"https://fantasylion.github.io/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://fantasylion.github.io/tags/tool/"}]},{"title":"使用canvas制作视频图片特效","slug":"2015-4-17-canvas_make_image_effect","date":"2015-04-16T16:00:00.000Z","updated":"2015-04-16T16:00:00.000Z","comments":true,"path":"program/2015-4-17-canvas_make_image_effect/","link":"","permalink":"https://fantasylion.github.io/program/2015-4-17-canvas_make_image_effect/","excerpt":"Canvas是html5上的一个画布标签,功能有点类似java的swing.可以在canvas上画线条 弧线, 文字 就是画布的功能. 具体提供的js函数看","text":"Canvas制作视频图片特效 Canvas介绍 Canvas是html5上的一个画布标签,功能有点类似java的swing.可以在canvas上画线条 弧线, 文字 就是画布的功能. 具体提供的js函数看http://www.w3school.com.cn/tags/html_ref_canvas.asp/ 简单介绍一下使用: 12345Var canvas &#x3D; document.documentElementById(“canvasId”);Var ctx &#x3D; canvas.getContext(“2d”);&#x2F;&#x2F;获取维数对象ctx.drawImage(img);&#x2F;&#x2F;img为dom图片对象, 还有其他可选参数 剪切坐标 和 放置到canvas上的坐标 给图片添加特效 原理: 图片通过drawImage函数 绘制到 canvas 上之后, 用getImageData函数可以获得 图片的imageData对象, imageData里有一个data数组存放的是 此图片的r g b a (三原色 和透明度). 将取出的data数组修改成对应特效数组, 用putImageData函数 重新数据放回canvas上即可. 小demo 代码(将图片设置成灰白效果 原理: 将r g b 设置成rgb平均数): 123456789101112131415161718192021222324252627282930&lt;img id&#x3D;”image1” src&#x3D;”&#x2F;img.jpg” &#x2F;&gt;&lt;canvas id&#x3D;”can” width&#x3D;”500” heigth&#x3D;”300”&gt; &lt;&#x2F;canvas&gt;&lt;!-- 注意: canvas的宽高只能通过属性设置, 在style中设置没有效果 --&gt;Var img &#x3D; document.documentElementById(“imgage1”);Var canvas &#x3D; document.documentElementById(“can”);Var ctx &#x3D; canvas.getContext(“2d”);&#x2F;&#x2F;获取维数对象ctx.drawImage(img);Var imgData &#x3D; ctx.getImageData(0, 0, 500, 300);For ( var i &#x3D; 0, len &#x3D; imgData.data.length, avgRgb; i &lt; len; i +&#x3D; 4) &#123;avgRgb &#x3D; (imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2]) &#x2F; 3;imgData.data[i] &#x3D; avgRgb;imgData.data[i + 1] &#x3D; avgRgb;imgData.data[i + 2 ] &#x3D; avgRgb;&#125;ctx.putImageData(imgData, 0, 0); 给视频添加特效 原理: 与图片的原理类似,只是要绘制视频每一帧的画面, 视频每播放一帧,就在canvas上绘制一帧画面 小demo 代码 (将视频画面红色调高 原理: 将r g b 中的r 调高) 12345678910111213141516171819202122232425262728&lt;video id&#x3D;”vid1” src&#x3D;”&#x2F;vid1.mp4” autoplay&#x2F;&gt;&lt;canvas id&#x3D;”can” width&#x3D;”500” heigth&#x3D;”300”&gt; &lt;&#x2F;canvas&gt;Var vid&#x3D; document.documentElementById(“vid1”);Var canvas &#x3D; document.documentElementById(“can”);Var ctx &#x3D; canvas.getContext(“2d”);&#x2F;&#x2F;获取2维对象function drawVidEffect() &#123;ctx.drawImage(vid);Var imgData &#x3D; ctx.getImageData(0, 0, 500, 300);For ( var i &#x3D; 0, len &#x3D; imgData.data.length, avgRgb; i &lt; len; i +&#x3D; 4) &#123;imgData.data[i] +&#x3D; 50;&#125;ctx.putImageData(imgData, 0, 0);setTimeout( drawVidEffect, 20 );&#125; 注意 如果视频或者图片所在的域名 跟canvas所在域名不一样 或者 不在服务器上运行 会报错: 1Uncaught SecurityError: Failed to execute &#39;getImageData&#39; on &#39;CanvasRenderingContext2D&#39;: The canvas has been tainted by cross-origin data. 解决办法:将图片或者视频加上属性crossOrigin但是添加后不能更换src地址 详见: http://camnpr.com/archives/1117.html/ http://camnpr.com/TuiJianTools/html5/canvas-cross-domain-images.html/","categories":[{"name":"program","slug":"program","permalink":"https://fantasylion.github.io/categories/program/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://fantasylion.github.io/tags/JavaScript/"}]},{"title":"Jquery 插件开发","slug":"2015-03-24-jQuery-plugin","date":"2015-03-23T16:00:00.000Z","updated":"2015-03-23T16:00:00.000Z","comments":true,"path":"program/2015-03-24-jQuery-plugin/","link":"","permalink":"https://fantasylion.github.io/program/2015-03-24-jQuery-plugin/","excerpt":"jQuery已经被广泛使用，凭借其简洁的API，对DOM强大的操控性，易扩展性越来越受到web开发人员的喜爱。本文简单介绍一下如何开发jQuery的插件","text":"前言 jQuery已经被广泛使用，凭借其简洁的API，对DOM强大的操控性，易扩展性越来越受到web开发人员的喜爱，本文简单介绍一下如何开发jQuery的插件 开发插件的方式有两种 类级别的开发 类级别的插件开发最直接的理解就是给jQuery类添加类方法，可以理解为添加静态方法。典型的例子有$.AJAX(),$.getJSON(),将函数定义于jQuery的命名空间中. 直接给jQuery添加一个函数. 1234567jQuery.pluginTest &#x3D; function() &#123; alert(“this is a plugin test add by class”);&#125;调用方式 : jQuery.pluginTest(); 通过jQuery.extend()添加函数 1234567891011jQuery.extend(&#123; pluginTest:function() &#123; alert(“this is a plugin test add by extends”); &#125;&#125;);调用方式 : jQuery.pluginTest(); 以命名空间的方式添加函数 优点: 避免某些函数或变量名将于其他jQuery插件冲突 1234567891011jQuery.pluginTest &#x3D; &#123; test : function() &#123; alert(“this is a plugin test add by namespace”); &#125;&#125;调用方式 : jQuery.pluginTest.test(); 对象级别的开发 第一种对象级别开发方式: 1234567jQuery.fn.extend(&#123;pluginTest : function() &#123; alert(“this is plugin test add by object1”);&#125;&#125;);调用 : $(“#id”).pluginTest(); 第二种对象级别开发方式: 1234567jQuery.fn.pluginTest &#x3D; function() &#123; alert(“this is plugin test add by object2”);&#125;调用 : $(“#id”).pluginTest(); 保证私有函数的私有性(闭包): 优点 : 定义更多的函数而不搅乱命名空间也不暴露实现 12345678910111213141516(function($) &#123; $.fn.pluginTest &#x3D; function() &#123; test(); &#125; function test() &#123; alert(“this is a closure test”); &#125;&#125;)(jQuery);调用: $(“#id”).pluginTest(); 通过接收参数options 改变默认的值 1234567891011121314151617(function($) &#123; $.fn.pluginTest &#x3D; function(options) &#123; var opt &#x3D; $.extend(&#123;width : 20, height : 20, color : ’ red’ &#125;, options); this.width(opt.width); this.height(opt.height); this.css(“color”, opt.color); &#125;&#125;)(jQuery)调用 : $(“#id”).pluginTest(&#123;width:50, height:50, color : ‘yellow’&#125;); 通过暴露属性改变默认值 12345678910111213141516171819202122232425262728293031323334353637(function () &#123; $.fn.pluginTest &#x3D; function() &#123; this.width($.fn.pluginTest.defaults.width); this.height($.fn.pluginTest.defaults.height); this.css(“color”, $.fn.pluginTest.defaults.color); &#125; $.fn.pluginTest.defaults &#x3D; &#123; Width : 20, height: 20, Color :‘red’ &#125;&#125;)(jQuery)调用: $(“#id”).pluginTest.defaults &#x3D; &#123; width : 50, height: 50, Color :‘red’&#125;$(“#id”).pluginTest(); 开发插件时需要注意的几点 推荐使用插件的命名方法jQuery.[插件名].js||[插件名].js 所有的对象方法都应当附加到JQuery.fn对象上面,而所有的全局函数都应当附加到JQuery对象本身上 在插件内部,this指向的是当前通过选择器获取的JQuery对象,而不像一般方法那样,内部的this指向的是DOM元素 可以通过this.each 来遍历所有的元素 所有方法或函数插件,都应当以分号结尾,否则压缩的时候可能会出现问题.为了更加保险写,可以在插件头部添加一个分号（;）,以免他们的不规范代码给插件带来 影响. 插件应该返回一个jQuery对象,以便保证插件的可链式操作. 链式操作：($(&quot;#div1&quot;).css(&quot;color&quot;,&quot;red&quot;).addClass(&quot;Add&quot;)) jQuery.extend() 和 jQuery.fn.extend()区别 jQuery.extend()函数 var tar = jQuery.extend(target, src1, src2...); 作用:将target,src1,src2中的属性合并添加到target中并返回 var tar = jQuery.extend({},target,src1,src2...); 作用:将target,src1…中的属性合并,target结构不变 var tar = jQuery.extend(boolean, target, src1, src2); Boolean 表示是否进行深度拷贝(是否复制嵌套对象) jQuery.extend(src); 作用:将该src合并到调用extend方法的对象中去,这里就是将src合并到jquery的全局对象中去 JQuery.fn.extend()函数 使用方法同上 jQuery.fn是什么 jQuery 源码如下: 123456789jQuery.fn &#x3D; jQuery.prototype &#x3D; &#123; init: function()&#123;&#x2F;&#x2F;... &#x2F;&#x2F;... &#125;&#125; 从源码中可以看出jQuery.fn.extend(src)就是将src添加到jQuery原型中由其实例对象调用","categories":[{"name":"program","slug":"program","permalink":"https://fantasylion.github.io/categories/program/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://fantasylion.github.io/tags/JavaScript/"}]},{"title":"tomat 欢迎页面设置在WEB-INF目录下时不显示问题","slug":"2015-02-19-tomcat-welcome","date":"2015-02-18T16:00:00.000Z","updated":"2015-02-18T16:00:00.000Z","comments":true,"path":"program/2015-02-19-tomcat-welcome/","link":"","permalink":"https://fantasylion.github.io/program/2015-02-19-tomcat-welcome/","excerpt":"在某次使用tomcat时，设置默认欢迎页面时一直报404，后来查明原因是路径要使用反斜线，本文用于记录此问题方便以后查找","text":"前言 在某次使用tomcat时，设置默认欢迎页面时一直报404，后来查明原因是路径要使用反斜线，本文用于记录此问题方便以后查找 正文 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt;&lt;display-name&gt;migu&lt;/display-name&gt;&lt;welcome-file-list&gt;&lt;welcome-file&gt;WEB-INF/view/index.jsp&lt;/welcome-file&gt;&lt;welcome-file&gt;WEB-INF/view/index.jsp&lt;/welcome-file&gt;&lt;welcome-file&gt;WEB-INF/view/index.html&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;&lt;/web-app&gt; windows下 配置为以上后，页面显示404 查明原因为：斜线问题导致 改为 1&lt;welcome-file&gt;WEB-INF\\view\\index.jsp&lt;/welcome-file&gt;","categories":[{"name":"program","slug":"program","permalink":"https://fantasylion.github.io/categories/program/"}],"tags":[{"name":"java","slug":"java","permalink":"https://fantasylion.github.io/tags/java/"}]},{"title":"Beyond Compare Lisense key","slug":"2014-07-08-beyond-compare-license-key","date":"2014-07-07T16:00:00.000Z","updated":"2014-07-08T04:00:00.000Z","comments":true,"path":"tool/2014-07-08-beyond-compare-license-key/","link":"","permalink":"https://fantasylion.github.io/tool/2014-07-08-beyond-compare-license-key/","excerpt":"Beyond Compare是一套由Scooter Software推出的软件，主要用途是对比两个文件夹或者文件，并将差异以颜色标示。本文记录一些Beyond Compare3的注册码","text":"介绍 Beyond Compare是一套由Scooter Software推出的软件，主要用途是对比两个文件夹或者文件，并将差异以颜色标示。 #Beyond Compare 3简体中文版官方下载地址： http://www.scootersoftware.com/BCompare-zh-3.2.4.13298.exe Beyond Compare 3密钥: 12345---- BEGIN LICENSE KEY ----mv1nPlXAywBDCdhxFc9QOVv6TBcQHLAXBQUAKTh3ie4fqSEOnWrPsnVkFyt0wAkJHweoExRJWWVwwCniKNROSdJzJXE6YVapYW7f+tRRXRFI4yn4NjjZ0RiiqGRCTVzwComUcXB-eiFWRBY6JpSsCNkmIxL5KsRCo442djHhTZE---- END LICENSE KEY ----- Beyond Compare 4 密钥 12345678---- BEGIN LICENSE KEY ----H1bJTd2SauPv5Garuaq0Ig43uqq5NJOEw94wxdZTpU-pFB9GmyPk677gJvC1Ro6sbAvKR4pVwtxdCfuoZDb6hJ5bVQKqlfihJfSYZt-xVrVU27+0JahFbqTmYskatMTgPyjvv99CF2Te8ec+Ys2SPxyZAF0YwOCNOWmsyqN5y9tq2Kw2pjoiDs5gIH-uw5U49JzOB6otS7kThBJE-H9A76u4uUvR8DKb+VcBrWu5qSJGEnbsXNfJdq5L2D8QgRdV-sXHp2A-7j1X2n4WIISvU1V9koIySNisHFBTcWJS0sC5BTFwrtfLEE9lEwz2bxHQpWJiu12ZeKpi+7oUSqebX+---- END LICENSE KEY -----","categories":[{"name":"tool","slug":"tool","permalink":"https://fantasylion.github.io/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://fantasylion.github.io/tags/tool/"}]}]}